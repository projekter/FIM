<?php

/*
 * Copyright (c) 2014, Benjamin Desef
 * All rights reserved.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * This program is licensed under the Creative Commons
 * Attribution-NonCommercial-ShareAlike 4.0 International License. You should
 * have received a copy of this license along with this program. If not,
 * see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.
 */

if(@FrameworkPath === 'FrameworkPath')
   die('Please do not call this file directly.');

abstract class Database {

   private static $connections = [];
   private static $activeConnection = null;

   private final function __construct() {

   }

   /**
    * Parses a connection file and returns a valid DatabaseConnection instance
    * or null if there was no connection information at all.
    * @param string $connectionFile
    * @return DatabaseConnection|null
    * @throws DatabaseException
    */
   private static final function loadConnectionFile($connectionFile) {
      $hierarchy = Router::normalizeFIM($connectionFile, true);
      if(empty($hierarchy) || $hierarchy[0] !== ResourceDir)
         throw new DatabaseException(I18N::getInternalLanguage()->get(['database',
            'invalidFilenameScope'],
            ['//' . implode('/', $hierarchy), CLI ? 'script' : 'content']));
      $connections = &self::$connections;
      $folder = ResourceDir;
      $lastConnection = $lastRecursive = null;
      array_shift($hierarchy);
      $end = count($hierarchy) - 1;
      foreach($hierarchy as $key => $cur) {
         if(!isset($connections[$folder]))
            if(is_file(CodeDir . "$folder/fim.database.txt"))
               $connections[$folder] = self::buildConnectionFile("$folder/fim.database.txt");
            else
               $connections[$folder] = false;
         if($connections[$folder] !== false) {
            $lastConnection = $connections[$folder];
            if($lastConnection->isRecursive())
               $lastRecursive = $lastConnection;
         }
         if($key !== $end)
            $folder .= "/$cur";
      }
      return ($connections[$folder] !== false) ? $lastConnection : $lastRecursive;
   }

   /**
    * Creates the cache upon a connection file
    * @param string $connectionFile
    * @return DatabaseConnection
    * @throws DatabaseException
    * @throws Exception
    */
   private static final function buildConnectionFile($connectionFile) {
      $cacheFile = 'cache/connections/' . md5($connectionFile) . '.php';
      $absCacheFile = CodeDir . $cacheFile;
      $absConnectionFile = CodeDir . $connectionFile;
      if(!is_dir(CodeDir . 'cache/connections') && !mkdir(CodeDir . 'cache/connections', 0700, true))
         throw new FIMInternalException(I18N::getInternalLanguage()->get(['database',
            'cache', 'writeError', 'directory']));
      $connectionTimestamp = filemtime($absConnectionFile);
      $cacheTimestamp = @filemtime($absCacheFile);
      if($cacheTimestamp === $connectionTimestamp)
         return require $absCacheFile;
      $now = date('Y-m-d H:i:s');
      $connectionContent = file($absConnectionFile, FILE_SKIP_EMPTY_LINES);
      if(isset($connectionContent[0]) && strcasecmp(trim($connectionContent[0]),
            'delete') === 0) {
         if(is_file($absCacheFile) && !@unlink($absCacheFile))
            Log::reportInternalError(I18N::getInternalLanguage()->get(['database',
                  'cache', 'unlinkError', 'cache'], [$cacheFile]));
         if(!@unlink($absConnectionFile))
            Log::reportInternalError(I18N::getInternalLanguage()->get(['database',
                  'cache', 'unlinkError', 'rules'], ["//$connectionFile"]));
         return false;
      }
      if(($parentConnectionFile = dirname($connectionFile)) !== ResourceDir)
         $parentConnectionFile = "'//" . addcslashes(dirname($parentConnectionFile) . '/fim.database.txt',
               "\\'") . "'";
      else
         $parentConnectionFile = 'null';
      $parsed = self::parseConnectionFile($connectionContent, "//$connectionFile");
      $connectionFileStr = "'//" . addcslashes($connectionFile, "\\'") . "'";
      $cacheContent = <<<Cache
<?php

/* This is an autogenerated cache file. Do not change this file, it might be
 * overwritten at any time without notification.
 * The original file is //$connectionFile.
 * Date of generation: $now.
 */

return new DatabaseConnection($parsed, $connectionFileStr, $parentConnectionFile);
Cache;
      if(@file_put_contents($absCacheFile, $cacheContent) === false)
         throw new FIMInternalException(I18N::getInternalLanguage()->get(['database',
            'cache', 'writeError', 'content'], [$cacheFile]));
      if(!touch($absCacheFile, $connectionTimestamp))
         throw new FIMInternalException(I18N::getInternalLanguage()->get(['database',
            'cache', 'writeError', 'timestamp'], [$cacheFile]));
      # Now try to include the cache file to see whether there is a syntax
      # error. There will be no checking for connection errors.
      # If there is a parsing error, make use of the shutdown function which
      # will write this error to the log
      $shutdownKey = Config::registerShutdownFunction(function() use ($cacheFile, $connectionFile) {
            Log::reportInternalError(I18N::getInternalLanguage()->get(['database',
                  'cache', 'syntaxError', 'hard'], ["//$connectionFile", $cacheFile]));
         });
      try {
         $ret = require $absCacheFile;
      }catch(Exception $e) {
         # No parsing error, only an exception
         Config::unregisterShutdownFunction($shutdownKey);
         throw $e;
      }
      Config::unregisterShutdownFunction($shutdownKey);
      return $ret;
   }

   private static function parseConnectionFile(array $content, $currentFileName) {
      $result = [];
      foreach($content as $line) {
         if($line === '')
            continue;
         if(!preg_match('/^\s*+([^=\s]++)\s*+=\s*+(\S*+)\s*+$/', $line, $matches))
            throw new DatabaseException(I18N::getInternalLanguage()->get(['database',
               'cache', 'syntaxError'], [$currentFileName, $line]));
         $key = strtolower($matches[1]);
         if(isset($result[$key]))
            throw new DatabaseException(I18N::getInternalLanguage()->get(['database',
               'cache', 'semanticError', 'doubleKey'], [$currentFileName, $key]));
         $value = strtolower($matches[2]);
         switch($key) {
            case 'recursive':
            case 'persistent':
               if($value !== 'true' && $value !== 'false')
                  throw new DatabaseException(I18N::getInternalLanguage()->get(['database',
                     'cache', 'semanticError', 'invalidValue'],
                     [$currentFileName, $key, 'true, false', $line]));
               $result[$key] = "'$key' => $value";
               break;
            case 'driver':
               static $drivers = ['4d' => true, 'cubrid' => true, 'dblib' => true,
                  'ibm' => true, 'informix' => true, 'mssql' => true, 'mysql' => true,
                  'oracle' => true, 'odbc' => true, 'pgsql' => true, 'sqlite' => true,
                  'sqlsrv' => true, 'sybase' => true];
               if(!isset($drivers[$value]))
                  throw new DatabaseException(I18N::getInternalLanguage()->get(['database',
                     'cache', 'semanticError', 'invalidKey'],
                     [$currentFileName, $key, implode(',', array_keys($drivers)),
                     $line]));
               $matches[2] = $value;
            case 'host':
            case 'user':
            case 'password':
            case 'database':
            case 'dsn':
               $result[$key] = "'$key' => '" . addcslashes($matches[2], "\\'") . "'";
               break;
            case 'port':
               $result['port'] = "'$key' => " . (int)$value;
               break;
            default:
               throw new DatabaseException(I18N::getInternalLanguage()->get(['database',
                  'cache', 'semanticError', 'invalidKey'],
                  [$currentFileName, $key]));
         }
      }
      return '[' . implode(', ', $result) . ']';
   }

   /**
    * Loads a database configuration that fits to the given path. This function
    * has to be called at least once in order to make database functions work.
    * @param string $path
    * @return DatabaseConnection
    */
   public static final function setActiveConnection($path) {
      return self::$activeConnection = self::loadConnectionFile("$path/fim.database.txt");
   }

   /**
    * Gets the current connection object that can be worked with. Will ensure
    * that the connection is established.
    * @param boolean $require (default true) Throw an exception when there is
    *    no connection to work with
    * @return DatabaseConnection
    * @throws DatabaseException
    */
   public static final function getActiveConnection($require = true) {
      if(self::$activeConnection === null) {
         if($require)
            throw new DatabaseException(I18N::getInternalLanguage()->get(['database',
               'unestablishedConnection']));
      }else
         self::$activeConnection->getConnection();
      return self::$activeConnection;
   }

   /**
    * Sets a database connection to a previously obtained value
    * @param DatabaseConnection $connection
    * @return DatabaseConnection
    */
   public static final function restoreConnection(DatabaseConnection $connection =
   null) {
      return self::$activeConnection = $connection;
   }

}
