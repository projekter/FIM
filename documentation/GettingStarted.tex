% !TeX spellcheck = en_US
\documentclass{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{lmodern,microtype,array,tabularx,setspace,fixltx2e,tikz,xcolor,upquote,framed,calc,floatrow,etoolbox,ccicons,multicol}
\usepackage[cachedir=cache/,cache]{minted}
\usepackage[margin=10pt,font=small,labelfont=bf,labelsep=endash]{caption}
\usepackage[hidelinks,breaklinks=false]{hyperref}

\deffootnote[1em]{1em}{1em}{\textsuperscript{\thefootnotemark}}
\renewcommand{\familydefault}{\sfdefault}

\title{Getting Started With FIM}
\author{Benjamin Desef}
\date{\ccbyncsa}

% NetBeans colors
\definecolor{nbBlue}{rgb}{0, 0, .9}
\definecolor{nbOrange}{rgb}{.8, .48, 0}
\definecolor{nbGreen}{rgb}{0, .6, 0}
\definecolor{nbYellow}{rgb}{1, 1, .79}
\definecolor{nbGrey}{rgb}{.59, .59, .59}
\definecolor{backgroundColor}{rgb}{.94, .94, .94}
\definecolor{shadecolor}{named}{nbYellow}

\floatsetup[listing]{style=Plaintop}
\AfterEndEnvironment{listing}{\vspace*{-5mm}}
\setminted{fontsize=\scriptsize,linenos,frame=lines}
\newminted{php}{}
\newminted[smartycode]{html+smarty}{}
\newminted{mysql}{}
\newmintedfile{php}{}
\newmintedfile[smartyfile]{html+smarty}{}
% For correct syntax highlighting in TeXstudio, we will use \lstinline as code identifier
\newmintinline[lstinline]{php}{startinline}
\newmintinline[smarty]{smarty}{}
\newmintinline[mysql]{mysql}{}
\newmintinline[fimrule]{fimrule}{}

\newcommand{\fim}{\textbf{F}ramework \textbf{Im}proved}
\renewcommand{\arraystretch}{1.4}
\setlength{\parindent}{0pt}
\setlength{\premulticols}{0pt}
\setlength{\postmulticols}{0pt}

\begin{document}
   \onehalfspacing
   \maketitle
   \tableofcontents \clearpage
   \section{Introduction}
      This manual will give you an idea of how \fim{} works. Therefore, a simple application will be built step-by-step. The idea of this application comes from Zend Framework's ``Skeleton Application'';  this document will also be oriented at Zend's ``Getting Started With Zend Studio 10 \& Zend Server 6''. You should already know about \emph{why} to use a Framework and be familiar with Smarty template syntax. \\
      The third chapter contains a reference that lists every public function grouped by the file they occur in. \enlargethispage{\baselineskip}
   \section{The demo application}
      We will shortly explain the directory structure that our final demo application will have. The top directory that contains all files that you will create while working through this document is called \emph{CodeDir}. Everything will take place in this directory. \autoref{directories} shows the top-level directory structure of CodeDir. This table is intended for a quick overview only. You do not need every directory in every installation of FIM. This guide will explain step-by-step what is important when creating an application.
      \begin{table}[htbp]
         \centering
         \begin{tabular}{p{2.5cm}||p{11.5cm}}
            File/Directory & Description \\\hline\hline
            \texttt{.htaccess} &
               Web server configuration file. Instructs Apache HTTPD to redirect all requests to the controller. \\\hline
            \texttt{index.php} &
               Controller. Starts FIM, contains configuration \\\hline
            \texttt{cache/} &
               Automatically-created directory that contains several files that are generated by FIM. Do not change the contents of this directory (except for deleting, if necessary). \\\hline
            \texttt{content/} &
               Base directory for web access. This directory contains all modules and data that is available via the browser. \\\hline
            \texttt{data/} &
               Database directory. This directory contains the ORM classes that map table structures to PHP objects. \\\hline
            \texttt{fim/} &
               Directory that contains FIM's source files. Do not change anything in this directory unless you are very certain. This directory might also be located in an include path instead of CodeDir. \\\hline
            \texttt{locales/} &
               Locales directory. The source and compiled ICU resource files are located in this directory. \\\hline
            \texttt{logs/} &
               Automatically-created directory that contains the logfiles. \\\hline
            \texttt{plugins/} &
               Plugin directory. A plugin is any kind of external library that is not delivered with FIM but that shall be available for use in your source code. \\\hline
            \texttt{script/} &
               Base directory for console access. This directory contains all modules and data that is available via command line interface.
         \end{tabular}
         \caption{Overview about FIM's top-level directory structure}
         \label{directories}
      \end{table}
   \subsection{Enabling FIM}
      FIM does not need many files in order to function properly. \\
      Create an empty directory under your DocumentRoot if you do not wish to work directly in the main folder of your web server. \\
      You will then need to provide FIM's program files. It is possible to extract these to a folder in your include path, but you may also create a new folder named \texttt{fim} and extract the files at this location. \\
      To enable FIM, you will need to create two files (assuming you are using Apache HTTPD): one controller file and one htaccess configuration file for the server.
      \begin{listing}[H]
         \caption{The controller file: \texttt{index.php}}
         \label{index}
         \begin{phpcode}
<?php
   require 'fim/fim.php';
   fimInitialize();
         \end{phpcode}
      \end{listing}
      \autoref{index} shows the content of the controller. At the beginning, this file will contain no more than three lines. But you may---and later on will---add some configuration parameters to the initialization function call. Note that you may have to adjust the path to \texttt{fim.php}, which lies in FIM's program folder.
      \begin{listing}[H]
         \caption{The server configuration: \texttt{.htaccess}}
         \label{htaccess}
         \inputminted{apache}{demo/.htaccess}
      \end{listing}
      In order to configure Apache properly, you also need to copy the \texttt{.htaccess} configuration file to the same directory as the controller file. This configuration shows two important points:
      \begin{itemize}
         \item
            \texttt{mod\_rewrite} is required for using FIM. This module \emph{has} to be activated. If you are using a server software different to Apache, there are similar settings or extensions that have to be configured in a way that every request is forwarded to the controller file.
         \item
            \texttt{mod\_xsendfile} should be used and activated. XSendFile is a module that allows resource-friendly delivery of files. Similar modules exist on other server softwares. FIM is able to automatically detect which server is used and will determine which measures to take to use the feature. It can however not determine if the module is present or installed on the server. This means that if you do \emph{not} have XSendFile (Apache, Cherokee), XSendFile2 (Lighttpd) or X-Accel-Redirect (Nginx) available although you are using one of those servers, you have to configure FIM not to use it. For this purpose, you need to modify a line in the controller \texttt{index.php}:
            \begin{phpcode*}{firstnumber=3,startinline}
   fimInitialize(['x-sendfile' => 'none']);
            \end{phpcode*}
      \end{itemize}
      After you have set up this two files, \fim{} is ready to go.
   \subsection{The demo application}
      Our demo application shall be a to-do list manager. We therefore need four pages:
      \begin{itemize}
         \item \textbf{Home} \\
            This page will display the list of to-do items.
         \item \textbf{Add new item} \\
            This page will provide a form for adding a new item.
         \item \textbf{Edit item} \\
            This page will provide a form for editing an item.
         \item \textbf{Delete item} \\
            This page will confirm that we want to delete an item and then delete it.
      \end{itemize}
      As this design is quite simple, you may not yet realize the differences of FIM in contrast to many other frameworks. While it is quite common that a framework is based on modules which run actions---so we have a three-level hierarchy: controller, module, action---, FIM takes a slightly different approach. It is often necessary that actions perform quite complex operations, while belonging to a single module. It would be perfectly possible to split actions in different functions and thus to structure the jobs. However, this makes the whole module itself messy, containing lots of functions that belong to different actions. For this purpose, FIM allows a much bigger hierarchy. The controller invokes the module, but every module does only implement one single action. As every module has its own folder, structuring workflow works very effectively. \\
      We will store information about our to-do items in a database. A single table will suffice with the following fields:
      \begin{table}[htbp]
         \centering
         \begin{tabular}{l||l|l|l}
            Field name
               & Type
               & Null?
               & Notes \\\hline\hline
            \texttt{id}
               & \mysql!integer!
               & No
               & Primary key, auto-increment \\\hline
            \texttt{title}
               & \mysql!varchar(100)!
               & No
               & Name of the file on disk \\\hline
            \texttt{completed}
               & \mysql!tinyint!
               & No
               & Zero if not done, one if done \\\hline
            \texttt{created}
               & \mysql!integer!
               & No
               & Date that the to-do item was created
         \end{tabular}
      \end{table} \\
      FIM works with PDO, so lots of database drivers are supported. In this demo application we will use MySQL. Create a database called \texttt{mytasklist} and run these SQL statements to create the task\_item table and some sample data:
      \begin{mysqlcode}
CREATE TABLE `task_item` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `title` VARCHAR(100) NOT NULL,
  `completed` TINYINT NOT NULL,
  `created` INT NOT NULL,
  PRIMARY KEY (`id`));

INSERT INTO `task_item`(`title`, `completed`, `created`)
  VALUES('Purchase conference ticket', 0, UNIX_TIMESTAMP());
INSERT INTO `task_item`(`title`, `completed`, `created`)
  VALUES('Book airline ticket', 0, UNIX_TIMESTAMP());
INSERT INTO `task_item`(`title`, `completed`, `created`)
  VALUES('Book hotel', 0, UNIX_TIMESTAMP());
INSERT INTO `task_item`(`title`, `completed`, `created`)
  VALUES('Enjoy conference', 0, UNIX_TIMESTAMP());
      \end{mysqlcode}
      Now we need to make FIM aware of this table. Create a directory under CodeDir that is named \texttt{data}. This directory will contain all table representations. So we need to create a new PHP file that is called \texttt{task\_item.php}, which is exactly the table name plus the extension \texttt{.php}. \\
      FIM organizes all files with the help of namespaces. In a properly set-up application, you should never need to include files by yourself. FIM will decide where to look for the required source files by examining the namespace of the unknown class: It will always be the directory path, relative to CodeDir. The only exception is made for the files that come with FIM itself: Classes that shall be accessed by you are in global namespace. Classes that are for internal use only are in the namespace \texttt{fim}. It should never be necessary to access a class or function in this namespace directly. \\
      So our newly created file starts like this:
      \begin{phpcode}
<?php

namespace data;
      \end{phpcode}
      Next, we need to supply FIM with the necessary information about the table. As our table has a primary key, we can inherit the class provided by FIM \texttt{\textbackslash PrimaryTable}. Note the starting backslash, which will assure that we are in the right namespace.
      \begin{phpcode*}{firstnumber=5,startinline}
class task_item extends \PrimaryTable {

}
      \end{phpcode*}
      Now FIM knows about the existence of the table, but nothing about its structure yet. By delivering a static property \lstinline!$columns!, we will specify the table structure:
      \begin{phpcode*}{firstnumber=7,startinline}
   protected static $columns = [
      'id' => '+int',
      'title' => 'string',
      'completed' => 'bool',
      'created' => 'int',
   ];
      \end{phpcode*}
      Now we have to decide what features should be possible with this table: We certainly want to create new tasks and we also want to delete existing ones. Then we will need to fetch all items---and we need the possibility to get a single task by its id. This leads to four methods:
      \begin{phpcode*}{firstnumber=14,startinline}
   /**
    * @param string $title
    * @param bool $completed
    * @return self
    */
   public static function create($title, $completed) {
      return parent::createNew((string)$title, (bool)$completed, time());
   }

   /**
    * @return bool
    */
   public function delete() {
      return parent::delete();
   }

   /**
    * @return self[]
    */
   public static function fetchAll() {
      return parent::findBy([], '"completed" ASC, "title" ASC');
   }

   /**
    * @param int $id
    * @return self|null
    */
   public static function fetchById($id) {
      return parent::findOneBy(['id' => (int)$id]);
   }
      \end{phpcode*}
      All methods have in common that they are very small and only invoke methods of the parent class. \\
      The first method, \lstinline!create!, is used to create a new object. The function that is responsible for this action in the parent class is called \lstinline!createNew!. It is protected by default and requires its parameters to be the fields in the same order as specified in the \lstinline!$fields! array.
      The autoincrement key must not be passed as a parameter. The need to write a wrapper function allows to ensure that all parameters are of the right type; furthermore, one can include validity checks or default values. \\
      The second method, \lstinline!delete! is only used to make the parent-class function \lstinline!delete! public. It can however be used to include checks which assure that deletion is possible. \\
      The third method, \lstinline!fetchAll!, retrieves all tasks that are stored in the database and returns them in an array. For this purpose, it uses the method \lstinline!findBy!. As a first parameter, this method requires an array of \mysql!WHERE!-restrictions; as second parameter, an \mysql!ORDER BY! string may be given. Note that in MySQL, column names normally have to be enclosed in backticks (\verb!`!), whereas SQL standard defines the double quote (\verb!"!) as the character required for this. When using MySQL, FIM will automatically issue a command that makes MySQL aware of this SQL standard, so using the double quote will be valid (use single quotes for strings). This simplifies changing between database systems. \\
      Finally, the last method, \lstinline!fetchById!, retrieves one single task. The arguments for \lstinline!findOneBy! are the same as for \lstinline!findBy!. The difference is the result type: Only the first object that fits the query is returned or \lstinline!null! if there is none. \\
      \fim{} provides \lstinline!find...! as well as \lstinline!get...! methods. The \lstinline!getBy! and \lstinline!getOneBy! functions work as their \lstinline!find! counterparts, but they allow to enter more complex conditions that cannot be reduced to fitting a single value. See the doccomments for further information. \\
      As a last step---which is not required, but handsome---we create doccomments for our class:
      \begin{phpcode*}{firstnumber=5,startinline}
/**
 * @property-read int $id
 * @property string $title
 * @property bool $completed
 * @property int $created
 */
      \end{phpcode*}
      Our database layer is now complete. The database object can be used in modules, which we will create next.
   \subsection{Creating modules}
      You already know that FIM organizes its content in modules. When you try to access our demo application at the current state, you will be presented with an error message: \texttt{Web access is not set up.}. This is because FIM can be used in web mode as well as in command line mode. At the current state, no option of these is available. To activate web access, simply create the folder \texttt{content} under CodeDir. When you now refresh our demo application, you will see a directory listing of the \texttt{content/} directory in FIM style instead. Unsurprisingly, this listing does not contain much more than the \texttt{``.''} virtual folder. \\
      Note that directory listing can be configured: By default, it is only available in development mode. You may switch to production by adding the array entry \lstinline!'production' => true! to the configuration. The configuration is the array that is passed to the function \lstinline!fimInitialize!. When you now reload the demo application once again, you will see a 401 (Forbidden) error message. \\
      FIM has just created another directory for you: \texttt{logs/}. This directory already contains three files which are worth a short explanation.
      \begin{itemize}
         \item \textbf{customError.log} \\
            This file is a user-defined error log. FIM will not write anything into this log file unless you call \lstinline!\Log::reportCustomError! in your code.
         \item \textbf{error.log} \\
            This is the general purpose error log. It should contain one line: \texttt{The error 401 was triggered while invoking the URI \textvisiblespace.}, where \textvisiblespace{} is the URL that you just called when you got a 401 error. \\
            Although the 401 error was logged here, this is not the main purpose for this log file. It will contain all kinds of errors that arise because of errors in your code or configuration. This includes fatal as well as non-fatal errors: Unhandled exceptions will be logged as well as language keys that did not exist.
         \item \textbf{internalError.log} \\
            This is the log file for all errors that occur within FIM, but that are most likely not due to an error you made, but due to bugs of FIM, PHP or the operating system. In other words: It contains all errors FIM did not expect. If an error is logged here, it left FIM in an unstable state and it is possible that this state will be permanent if you do not take countermeasures. Examples are when writing a cache file failed. This problem can be fixed e.g.\ by verifying that FIM has the necessary access rights to the cache directory, it is not write-protected, there is enough space or whatever comes to your mind. But FIM cannot continue working without this cache file being written. However, this might only affect parts of your application and might not be noticed without viewing the log.
      \end{itemize}
      FIM has a built-in mailing function that allows automatic notification when errors occur. Some errors that are uncritical or duplicate very often will never trigger a mail, but others do. For this purpose, set the configuration entry \lstinline!'mailErrorsTo'! to your e-mail address. If your mail server requires a certain From header, you may specific it in the entry \lstinline!'mailFrom'!. \\
      But we now want to create our modules. For this purpose, its recommended to turn the production state off again, so that error messages will be displayed directly to you. \\
      As mentioned earlier, every page is a module. We have assembled a list of all the pages we want to create before. So let's go! \\
      Our first page is the home. This page will display all the to-do items. We can choose: Either we could put the module directly in our \texttt{content/} directory or in a subdirectory. We will select the second option, as it is more straightforward for the developer. So let's create a directory called \texttt{tasks} in our \texttt{content/} directory. We chose this name as it describes the purpose of the application itself. We also have static resources such as CSS and JavaScript which we want to keep separate from our programming logic. \\
      We will now need to change this directory from a ``normal'' directory to a module. This is done by adding a file named \texttt{fim.module.php}. Any file that starts with \texttt{fim.} is considered a special file that will not be accessible to the user via a browser. But only a small number of filenames have a special meaning for FIM. Now we need to fill this file with content:
      \begin{listing}[H]
         \caption{Our first module, CodeDir\texttt{/content/tasks/fim.module.php}}
         \phpfile{demo/content_NoLocalization/tasks/fim.module.php}
      \end{listing}
      This is very nice, as it shows lots of interesting aspects:
      \begin{itemize}
         \item
            Once again, our namespace represents the directory structure.
         \item
            The class name of our module is \lstinline!Module!. This is required by FIM for any module class. Therefore, it is clear that only one module per namespace---i.e.\ per folder---can exist.
         \item
            The parent class of every module is \lstinline!\Module!. While it is possible that a module might inherit from another module, \lstinline!\Module! has to be the very superclass.
         \item
            The function \lstinline!execute()! is triggered when a directory with a module file in it is requested. This does not mean that a module has to implement this method: If it does not, a 404 (not found) error is triggered, which may be caught in any module at a valid point of the hierarchy. But we will talk about errors in \autoref{mainModule}.
         \item
            We can directly call our functions that were defined earlier in the table class; FIM will automatically load the class file.
         \item
            FIM uses a template system; a template is displayed by the method \lstinline!displayTemplate!. This method expects one parameter which points to the template file.
         \item
            FIM introduces its own path system. This will be very convenient to you, as you never have to deal with the problem of where your code is located absolutely. Furthermore, the path system is platform-independent; FIM takes care of all necessary transformations. \\
            The path delimiter is the forward slash. While you can use backslashes, FIM will always convert them to forward slashes. Although Windows uses the backslash as path separator, it accepts the forward slash, so there is no reason to take Windows in account. \\
            Relative paths are used as known from the console. The meta directories  \texttt{..} and \texttt{.} exist as in every file system. \\
            Absolute paths are handled a bit differently. The ``root directory'' of FIM is CodeDir. You cannot go beyond this directory; so it would be nice to define this directory as \texttt{/}. But on the other hand, any kind of URL that is used cannot go beyond ResourceDir (ResourceDir is a constant that is either \texttt{content} or \texttt{script}, depending on whether FIM runs in the browser or in the console). So we would also like to safe us from typing \texttt{/content/} or \texttt{/script/} all the time. FIM's path system is built on these ideas: \\
            Use \emph{two} forward slashes at beginning of the path in order to indicate that the path starts at CodeDir, so at the very top. \\
            Use \emph{one} forward slash at the beginning to indicate that the path starts at ResourceDir. This is of course dependent on the current execution context, so you shouldn't make use of this path style in functions that are used body in CLI and in web mode if you do not really know what you do. \\
            A note at the end: FIM does not change the behavior of PHP's internal file functions, as some third-party libraries may depend on them. So if you execute the statement \lstinline!rename('/oldname', '/newname');!, this will search the files in the file system's root, not in FIM's. But FIM does provide a convenient way for this: You may either use the function \lstinline!\Router::convertFIMToFilesystem()! before you pass the filename to internal functions or you can make use of the \texttt{fim://} protocol. Protocols are prepended to the filename and indicate the ``way of retrieval''; the default protocol is \texttt{file://}, which may be (and normally is) omitted\footnote{There's a little difference between a path starting with the \texttt{file://} protocol and a path without protocol. The former cannot be relative while the latter of course can.}. So the above call of the internal function \lstinline!rename! can be rewritten as \lstinline!rename('fim://oldname', 'fim://newname');!. You \emph{may} use this syntax for convenience; but keep in mind that it is not as fast as first converting the filename---and it will possibly cause confusion: As every protocol \emph{has} to use two forward slashes as separator, using \emph{two} of those will be relative to ResourceDir, using \emph{three} will be relative to CodeDir; real relativeness requires a starting dot after two slashes. This is not intuitive, but a design that comes out of PHP's protocol support\footnote{Please keep in mind that Smarty has its own protocol system. Smarty protocols only use the colon as separator, without slashes. The \texttt{fim:} protocol is implemented in Smarty as well (that's actually the way FIM achieves that you can use FIM paths in Smarty templates), but it is set as \emph{standard} here. So any path that is provided in templates automatically uses FIM style unless you prepend \texttt{file:} or a different protocol (which you generally should not do).}. As a summary: \vspace*{-.5\baselineskip}
            \begin{multicols}{2}
               \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3},fontsize=\scriptsize]
fim:///path  $\leftrightarrow$ //path
fim://path   $\leftrightarrow$ /path
fim://./path $\leftrightarrow$ path
             $\leftrightarrow$ ./path
               \end{Verbatim}
            \end{multicols}
         \item
            The current working directory is the module's directory. By specifying the filename \texttt{tasks.tpl}, this file is looked for in the current working directory which is location of the \texttt{fim.module.php} file. \emph{Do not rely on the include path! It will not work with FIM!}
         \item
            Assigning variables to \lstinline!$this! makes them available to the template.
         \item
            Modules can be quite small...
      \end{itemize}
      You can be tempted to think that accessing the database in line~9 will work by now. But do not forget what we have done so far: We created the database and the table in MySQL, the database layer in FIM and accessed the database layer. But what's still missing is the connection between MySQL and FIM. Why didn't we specify host, username and password right along with the database layer? \\
      MySQL and lots of other databases that PDO supports are multi-user databases where different users can have different privileges. Imagine the scenario that in a kind of very deep backend for super users, you wish to provide the possibility to create new tables, alter or drop existing ones and so forth. So really powerful features that are normally not needed in web applications. Or imagine there is a front-end which shall only have the SELECT privilege. \\
      You might think that end users never connect to the database, they can only interact via the application that you provide---and if you don't provide features to do this and that, it won't be done. That's a fair argument, but you might be in a team and not everyone is as reliable as you or you provide the possibilities ``just for development'', to make things easier, and then... Remember that anything that can possibly go wrong, does. \\
      So you create different database users with different privileges; therefore, you cannot specify connection information in the database layer, which is the same for your whole system. Instead, you put the information in your content directory and it takes effect for all modules that are at or below the level of the connection file in path hierarchy. \\
      As we have quite a simple architecture, we will only create one connection file directly in the \texttt{content} directory (which should be the most common case). This file is named \texttt{fim.database.txt}---so again it is not accessible from the outside (lucky as we are...). The file is in an INI-like format which is explained in-depth in the reference. For MySQL, it will look as follows:
      \begin{minted}{ini}
driver=mysql
host=127.0.0.1
database=mytasklist
user=<username>
password=<password>
persistent=true
      \end{minted}
      The given user will need SELECT, INSERT, UPDATE and DELETE privileges. You may leave \texttt{persistent} to \texttt{false} if you wish to; this setting specifies whether existing connections shall be reused from request to request. \\
      Next, we need to create the template that shall be displayed. If we called the module at the moment, we would be presented with an error message. So let's create a file named \texttt{tasks.tpl} in the module directory:
      \begin{listing}[H]
         \caption{Our first template, \texttt{/tasks/tasks.tpl}}
         \smartyfile{demo/content_NoLocalization/tasks/tasks.tpl}
      \end{listing}
      As you see, this template file will not compile on its own but instead only extend a file called \texttt{base.tpl}. We did this because HTML header and footer will be this same on every page and we do not want to repeat it. As mentioned before, every path or filename that appears within templates automatically uses FIM style. This means that \texttt{/base.tpl} is a file that is located in ResourceDir, i.e.\ \texttt{content/}. \\
      Although there are once again lots of interesting things to point out, let's first create this \texttt{/base.tpl} file:
      \begin{listing}[H]
         \caption{The parent template, \texttt{/base.tpl}}
         \smartyfile{demo/content_NoLocalization/base.tpl}
      \end{listing}
      So now we are done with the template files of our first page. Let's have a deeper look on what we wrote: \label{tf1}
      \begin{itemize}
         \item
            FIM provides a template function that is called \texttt{url}. You call this
            function whenever you wish to point to another resource of FIM. The function expects at least one parameter which contains the URL that is pointed to. This first parameter doesn't have name. You may pass further parameters to the function as well, but these require a name. This is needed when linking to a module: Modules may expect parameters in their \lstinline!execute! function. The name of these parameters is identical to the name you have to pass in here. \\
            Note that you must not make use of the \texttt{url} function when linking to a resource that lies on an external server.
         \item
            Smarty's auto-escape function is turned on by default. You should not change this feature; if you wish to output a variable directly---without \lstinline!htmlspecialchars! applied---, use the \texttt{nofilter} keyword. This keyword works for the \texttt{url}, \texttt{lurl} and \texttt{L} functions as well.
         \item
            Another template function provides easy access to FIM's internationalization functions, which are encapsulated in the class \lstinline!I18N!. As it is very uncomfortable to write \lstinline!I18N->getLanguage()->...!, the very short-named template function \texttt{L} is a replacement (which is also faster). \\
            The \lstinline!I18N! class is described in detail later on. It supplies several functions; the most important one should be \lstinline!get()!, which is used whenever a language key is fetched. But as we did not localize our application so far, this function doesn't play a role. Even without this function, the \lstinline!I18N! class is very helpful. Its function \lstinline!formatDate! takes a UNIX timestamp and converts it to a human-readable string representation of the date as required by the locale that is set at the moment. \\
            The aforementioned function \texttt{lurl} is a combination of both template functions. It calls \lstinline!I18N::translatePath! on a path that was gathered with the \texttt{url} function. But as this function is only important for multi-lingual applications, we will not talk about this at this moment.
      \end{itemize}
   \subsection{A preview in the browser}
      You can now execute the demo application in the browser. When you call the main directory, you will still see a directory listing. This is an issue we'll soon deal with. Then navigate to the \texttt{tasks} folder. You will now see a web page that contains a list of our four sample tasks with a proper-formatted date. \\
      However, this web page is still very old-fashioned. When you now open the default log file \texttt{logs/error.log}, you will see lots of 404 errors. The reason of this is that although we embedded lots of style and script files in our template, we did not create these files yet. \\
      So clear the log file and copy the directories \texttt{css}, \texttt{fonts}, \texttt{img} and \texttt{js} from the demo application archive into your \texttt{content} folder. Now refresh the page and it should look much better; your log should not report any error anymore.
   \subsection{Performing actions}
      There are several possibilities of what could be done next. Let's now add the modules for adding, editing and deleting a task. Creating the first module took about eight pages for you to read, but I promise that we won't need such an amount for the next three modules altogether!
   \subsubsection{The add module}
      The next steps should be very familiar: We create a directory called \texttt{add} under \texttt{content/tasks}. This directory will get the file \texttt{fim.module.php}:
      \begin{listing}[H]
         \caption{The \texttt{/tasks/add} module}
         \phpfile[lastline=9,frame=topline]
                 {demo/content_NoLocalization/tasks/add/fim.module.php}
      \end{listing}
      \phpfile[firstline=10,frame=bottomline,firstnumber=10]
              {demo/content_NoLocalization/tasks/add/fim.module.php}
      This module isn't very long either, although it creates a new task, checks the input for validity and redirects back to our main page. \\
      If the request mode was POST---so if a user submitted the form---, we retrieve the new title and remove leading and trailing whitespaces. If our title is now empty, we assign a template variable; if it isn't, we call the \lstinline!create! function of our \lstinline!task_item! class. Then we redirect back to the task listing with an external redirect that is executed by the user's browser. It's worth noticing that a call of the function \lstinline!redirect! (as well as for the function \lstinline!forward!, which will perform an \emph{internal} redirect) aborts the execution of the module, so our template never gets displayed when we did a redirect. \\
      We still need a template:
      \begin{listing}[H]
         \caption{The \texttt{/tasks/add/add.tpl} template}
         \smartyfile{demo/content_NoLocalization/tasks/add/add.tpl}
      \end{listing}
      You may now click at the link ``Add new item'' and check what we have done! First, leave the form empty and submit it. This should not be possible unless you use an old browser because of the HTML5 attribute \texttt{required}. Next, set the name to a space. Now the browser allows you to submit, but our code complains about the missing task name. At last, we should add a real item. Enter any name, check ``Completed'' or don't and submit. VoilÃ ---our task appears in the list.
   \subsubsection{The edit module}
      We create the directory \texttt{content/tasks/edit}. Our module will look like this:
      \begin{listing}[H]
         \caption{The \texttt{/tasks/edit} module}
         \phpfile{demo/content_NoLocalization/tasks/edit/fim.module.php}
      \end{listing}
      Now there is one new thing. We required the module to get one parameter which is called \lstinline!$task! and which is of our table's type. So how does FIM know where to take this parameter from? \\
      By default, the values for any parameter that is given to a module's execution function is taken from the GET values. This means that those parameter are generally to be considered unsafe! But GET parameters are mere strings, so why won't PHP complain when we set the typehint to our table? The answer is very easy: \emph{Without} the typehint, the parameter would be a string; \emph{with} the hint, it is an object of the class \lstinline!\data\task_item!. The typehint is not there to verify the correct type, but to indicate it! This very convenient feature of FIM is called \emph{autoboxing}. Autoboxing can be applied to every class that implements the \lstinline!Autoboxable! interface. As \lstinline!PrimaryTable!, the superclass of our table, does this, we can use autoboxing to convert a task's id to the task object. \\
      PHP's capabilities of typehints are not very elaborated; you cannot for example indicate primitive types. That's why FIM also evaluates the docblocks of methods; this is discussed later. \\
      One question remains: What happens if no task or an invalid one was given in the URL? As we did not allow \lstinline!null! for our parameter, our module will never get called. Instead, a 404 Not Found error is triggered. If we had allowed \lstinline!null!, our parameter would be \lstinline!null!. So autoboxing can reduce the amount of checks and transformations that you need to perform on user input drastically. \\
      We still need to create our edit template. As it is almost identical to the one used for adding and doesn't introduce anything new, it is not printed here. You may copy it from the archive. \\
      Try to edit an item by clicking on its name!
   \subsubsection{The delete module}
      The last directory that we create is \texttt{content/tasks/delete}. This module's purpose is to ask for a confirmation, then to delete the item and redirect back. You should be able to create the two files on your own by now, but you can also use the files from the archive. \\

      Now we are done with all the modules---and it took only three pages for three modules!
   \subsection{Speed}
      When you are calling the pages from the browser, you may experience some slowness. This has three possible reasons:
      \begin{itemize}
         \item
            FIM is a framework and as such slows you application down. This is a drawback that affects each and every framework, although FIM is built to be fast. You are encouraged to use a PHP opcode cacher such as APC (which comes with PHP) or XCache.
         \item
            You have just called a new page. The first call of every page requires FIM and Smarty to create several cache files. Those files will fill the folder \texttt{//cache} and will speed up execution, so this only affects the first call of a new page.
         \item
            You have XDebug enabled. While I encourage you to use XDebug in development, it affects speed badly. FIM is built to be high-performing even if XDebug is enabled\footnote{This is done by omitting curly braces where possible. XDebug will not generate debug information for loops or conditions without braces, which improves speed. But follow your styleguide as you did before.}, but it can't do magic. On production servers, XDebug shall be turned off.
      \end{itemize}
   \subsection{The main module} \label{mainModule}
      As we have seen before, our main page will present us with a directory listing (in development mode) or a 401 Forbidden error (in production mode). This is very uncomfortable. But does it mean that we have to create a module in this folder? \\
      Basically, yes. We will need a module for one particular reason: error handling. At the moment, when we access a resource that does not exist, we are presented a textual error message and the failed access is written to the log. The first aspect is not nice: While the error message suffices to tell the user what has happened, it should definitely be in the style of the rest of the application. The latter aspect is a nice feature for development, as you can immediately see when you have linked to a module or file that does not exist and thus you may resolve these invalid links. But in production you do generally not want to log all those access errors---they might not have been triggered by a wrong link you supplied, but by external mislinks or bots. That's why FIM only logs those errors in development mode. \\
      So let us create a module in \texttt{//content} that is responsible for error handling.
      \begin{listing}[H]
         \caption{Error handler module, \texttt{/fim.module.php}}
         \phpfile{demo/content_NoLocalization/fim.module.php}
      \end{listing}
      As it is very short, let's quickly add the corresponding template:
      \enlargethispage{.8cm}
      \begin{listing}[H]
         \caption{Error handler template, \texttt{/error.tpl}}
         \smartyfile{demo/content_NoLocalization/error.tpl}
      \end{listing}
      When you now try to fetch a resource that does not exist, you will see a nice error message in the style of our application. While the template looks very familiar, the module file shows some interesting things:
      \begin{itemize}
         \item
            As mentioned at the very beginning, a module does not have to have a \lstinline!execute! method.
         \item
            If an error occurs, the \lstinline!handleError! function is called with the error code as first parameter. But this is not the whole story:
         \item
            An error can be triggered manually or automatically. The latter is usually the case when a routing failed (404) or rules denied access (404/401).
         \item
            The error is triggered for a certain path. Let's do an example. We tried to access the URL \texttt{/demo/tasks/super/man}, while we assume that the DocumentRoot equals CodeDir. \\
            Now FIM tries to apply routings. We haven't discussed this so far, so let's simply say that FIM wants to transform this URL into a local path. URLs are marked in {\color{nbBlue}blue} while FIM paths will be {\color{nbGreen}green}.
            \begin{enumerate}
               \item {\color{nbBlue}\texttt{/}} \\
                  We start in ResourceDir, as this is the topmost folder that is accessible from the outside. There are no manual routings defined for this folder, so our current directory is {\color{nbGreen}\texttt{/}}.
               \item {\color{nbBlue}\texttt{/} + \texttt{demo}} \\
                  There are no manual routings defined for the path ``demo''. So FIM searches if there is a folder called ``demo'' in our current directory (files would not be found, as the current directory now contains a module, so direct file access is prohibited). It is, so our new directory becomes {\color{nbGreen}\texttt{/demo/}}.
               \item {\color{nbBlue}\texttt{/demo/} + \texttt{tasks}} \\
                  The same as before; our new directory becomes {\color{nbGreen}\texttt{/demo/tasks/}}.
               \item {\color{nbBlue}\texttt{/demo/tasks/} + \texttt{super}} \\
                  There are no manual routings for the path ``super'' in the current directory. FIM searches for a folder of this name, but does not find one. \\
                  Now a 404 error is triggered for the current directory, which is {\color{nbGreen}\texttt{/demo/tasks/}}.
            \end{enumerate}
         \item
            FIM will now try to handle this error. It searches for modules that can do this job:
            \begin{enumerate}
               \item {\color{nbGreen}\texttt{/demo/tasks/}} \\
                  This folder contains a module. FIM first checks whether this module implements the specific error handler \lstinline!handleError404!. It does not, so now FIM looks for the generic error handler \lstinline!handleError!. This one does not exists either, so FIM propagates to the parent directory.
               \item {\color{nbGreen}\texttt{/demo/}} \\
                  The same as before; we need to propagate.
               \item {\color{nbGreen}\texttt{/}} \\
                  This folder contains a module which provides the generic error handler. A new object of the module class is created---error handler always operate in fresh objects---and the handler is executed.
            \end{enumerate}
         \item
            An error handler can receive additional parameters. When the error is triggered manually via the \lstinline!Module::error()! function, you may pass optional parameters which will be present in every error handler.
         \item
            An error handler can get further details about the context of the error message. The method \lstinline!$this->getErrorDetails()! returns an associative array with the indexes \lstinline!'code'!, \lstinline!'file'!, \lstinline!'line'! and \lstinline!'trace'! which provide information about where the error function was called. This function will return \lstinline!null! for any error that was triggered by FIM (i.e.\ routing or rule errors). If you wish to get the URL that caused the error, call \lstinline!\Request::getURL()!. FIM makes use of the error codes 401 (Forbidden $\leftarrow$ rules), 404 (Not found $\leftarrow$ routing/rules) and 500 (Internal Server Error $\leftarrow$ internal problem while passing a file to the user). You may use any code that you desire (including the ones FIM uses). It is however encouraged that you stick to HTTP error codes because of:
         \item
            The error handler may return a value:
            \begin{itemize}
               \item \lstinline!self::PROPAGATE! \\
                  This value indicates that the handler might have processed the error or not, but FIM is required to propagate to the next handler in the chain.
               \item \lstinline!self::PROPAGATE_UP! \\
                  As \lstinline!self::PROPAGATE!, this return value requires FIM to look for the next handler. For this purpose, FIM will not call the generic error handler of the same module. This means that the two above return values are identical when used in a \lstinline!error()! function, but behave different when used in a specific error handler.
               \item \lstinline!int! \\
                  Any integer that is returned is set as the HTTP status code of the response (but only if this integer is a valid status code).
               \item \lstinline!null! \\
                  If nothing is returned, the HTTP status code will become the error number with which the handler was called.
               \item Anything else, e.g.\ \lstinline!false! or \lstinline!true! \\
                  These result values will be ignored and will not change the status code.
            \end{itemize}
            Note that if you require FIM to propagate but there is no further error handler, FIM's default error handler will be triggered (the one you have already seen).
         \item
            Note that the name ``error'' is used in a different context than in PHP. In PHP, errors are mechanisms that print a message to the user, they can have different levels of gravity---from ``harmless'' hints to fatal errors---and are related to a problem in your programming code. \\
            The term ``error'' as used here means ``any problem that is (most likely\footnote{A 404 error due to a wrongly typed URL is due to a error in your templates. But this kind of problem is indistinguishable to user-caused ones.}) not related to coding errors''. \\
            What does FIM with PHP's errors (assuming there are ones, of course...)? \\ First of all, every error will be logged in the default log file, \texttt{errors.log}. Second, when in production mode, a message will be printed for fatal errors, which informs about the error, but does not reveal any details. When in development mode, any error will be printed to the user as done by PHP's default error handler. \\
            An exception is made for error of type \lstinline!E_RECOVERABLE_ERROR!. Those errors are something crazy. While they are designed particularly for being catched, a \lstinline!try!-\lstinline!catch!-statement will not catch them, but the script will be aborted. This is because \lstinline!catch! only catches exceptions, but no errors. So FIM automatically converts every recoverable error into an exception of type \lstinline!ErrorException! which can then be caught.
         \item
            We did not talk about exception handling yet. As explained above, a FIM error has nothing to do with exceptions, so we need to discuss those. \\
            By default, exceptions are handled as errors. FIM will print a detailed analysis of the exception to the user when in development mode, and a hint when in production mode. If you know XDebug, the style of exception dump shall be very well-known for you. FIM's output is designed to be very close to the one used by XDebug (although it is not identical) so that you can get accustomed to it very quickly. \\
            If you wish to overwrite exception handling, you may create a function in your module with this signature:
            \lstinline!public function handleException(\Exception $e)!. The process of propagation is exactly as described for error handlers, but without support for HTTP status codes (you may still change \lstinline!\Response::$responseCode! if you wish). \\
            Note that we did not implement an own exception handler in our demo application. While it can be regarded as normal that exceptions are thrown, it should generally not occur that they are uncaught. So implementing an error handler is fine and recommended, as errors can be triggered by a misbehavior of the user; but for exceptions, FIM's own handler should generally suffice. But you may overwrite this default handler---just note that you are responsible for logging the exception with enough details for resolving it!
      \end{itemize}
   \subsection{Routing} \label{routing}
      So let us now come to routings, i.e.\ the way how FIM converts URLs to paths and vice versa. If you call the top page of our application, you will not see a directory listing, but a 404 page instead. This is not very nice. There are two ways to come to grips with this:
      \begin{itemize}
         \item
            We could create an \lstinline!execute! method in our top module and perform a redirect to the \texttt{tasks} directory. This would perhaps be the favorable approach.
         \item
            We might also create a routing that virtually ``removes'' the directory \texttt{tasks} from the URL. As you should really know about routings, we will choose this way.
      \end{itemize}
      You have already seen basic concepts of routing when we talked about error handling. The way FIM transforms a URL into a path is described in detail in the previous section---but one explanation is still missing. How can we define manual routings? \\
      Our target will be to apply the following rules (as before, {\color{nbBlue}blue} means URL, {\color{nbGreen}green} is path):
      \begin{itemize}
         \item {\color{nbBlue}\texttt{/css/*}}, {\color{nbBlue}\texttt{/fonts/*}}, ... \\
            Everything that is not located in the {\color{nbGreen}\texttt{/tasks/}} folder shall be accessible as before.
         \item {\color{nbBlue}\texttt{/}} $\leftrightarrow$ {\color{nbGreen}\texttt{/tasks/}} \\
            The top URL shall route to the {\color{nbGreen}\texttt{/tasks}} module.
         \item {\color{nbBlue}\texttt{/edit/}}, ... $\leftrightarrow$ {\color{nbGreen}\texttt{/tasks/edit/}}, ... \\
            Anything that is located in the {\color{nbGreen}\texttt{/tasks/}} directory shall be accessible as if it were in {\color{nbGreen}\texttt{/}}.
      \end{itemize}
      You might think about this twice, then create the file \texttt{fim.router.php} in our \texttt{content} directory: \thispagestyle{empty}\enlargethispage{2cm}
      \begin{listing}[H]
         \caption{Our routing, \texttt{/fim.router.php}}
         \phpfile{demo/content_NoLocalization/fim.router.php}
      \end{listing}
      Our router file is not much bigger than the informal description of what we wanted! What is done here? \\
      First of all, we extend the base class \lstinline!\Router! for all routings. This \emph{requires} to implement the two methods exactly as given in the listing.
      \begin{itemize}
         \item
            \lstinline!rewritePath! is responsible for transforming a path into a URL.
         \item
            \lstinline!rewriteURL! does the reverse.
         \item
            Both functions receive three parameters. The first one is an array that is filled with the path or URL segments of the requested resource, relative to the directory in which the router is located. The returned value is an array of the same structure, containing the transformed path segments. We will do another example soon.
         \item
            The second parameter contains all the GET parameters that the resource originally receives and is altered to contain the GET parameters that the routed resource will get.
         \item
            The third parameter can be set to \lstinline!true! if you wish to prevent FIM from applying further routings. This interrupts the routing chain and can thus cause invalid paths! Use with care (possible use case: A router is located in a deep file structure and you don't want FIM to look for further routings, as there are no ones).
         \item
            \lstinline!null! must be returned, when no routing whatsoever will be applied to the given resource, regardless of the parameters. Assuming that you don't want to rewrite the path or URL for the current parameters, but maybe for others, you \emph{have to} return the input array instead of \lstinline!null!---everything else will invalidate the cache and lead to unexpected behavior.
      \end{itemize}
      I think these explanations were the most abstract ones in this manual; thus, we will do another example. \\
      We will create a second router in the \texttt{tasks} directory. It looks like this:
      \begin{listing}[H]
         \caption{A second routing, \texttt{/tasks/fim.router.php}}
         \phpfile{demo/content_NoLocalization/tasks/fim.router.php}
      \end{listing}
      You have to delete the directory \texttt{//cache/templates} (or at least any file in this directory). Note that anything that changes static routings to dynamic ones requires purging the template cache! \\
      Please check the application in the browser. You will notice that our top directory no longer displays an error but the task list instead. Furthermore, any link pointing to add/edit/delete actions does not contain the \texttt{tasks} directory any more. But this was all achieved with the first routing. What did the second one do? \\
      In other frameworks, it is common not to use GET parameters but to append virtual ``subdi\-rectories'' to the URL. So while FIM would use a URL like \texttt{/edit/?task=1}, other frameworks would rather use the URL \texttt{/edit/1}. We won't discuss the pros and cons here. Simply open the first URL in the browser. You will see the edit page. Now view the source code and check for the \smarty!<form action="...">! tag. You will see that it equals the current URL. \\
      Then open the second URL in your browser. Thanks to our last routing, exactly the same page will appear! But if you view the source, you will notice that the tag's value equals the \emph{new} URL, without the GET parameter! \\
      So this is what the router does: When receiving a URL, it detects whether this URL uses FIM parameter style or the other one. In the latter case, the URL is rewritten so that FIM can parse it. When transforming a path back to a URL, our router still knows in which mode the request was issued and does the appropriate rewriting. So that's what the routers do---let's look at the how.
      \begin{itemize}
         \item
            We receive the URL {\color{nbBlue}\texttt{/edit/1}}. FIM now searches for a router in the top-level directory. There is one; FIM creates an object of this router. \emph{This object is never destroyed for the request; FIM will operate on this single object!}
         \item
            The function \lstinline!rewriteURL! is called with the URL relative to the router directory. In other words:
            \lstinline!$router->rewriteURL(['edit', '1'], [], $stopRewriting);!.
         \item
            The directory {\color{nbGreen}\texttt{/tasks/edit}} exists; thus our router returns the array \lstinline!['tasks', 'edit', '1']!; the parameters are unchanged. \\
            What does this mean?---FIM will \emph{replace} the received URL with the one returned by the router.
         \item
            We're done with the top level. Let's go to the next directory in our URL. This is {\color{nbBlue}\texttt{/tasks}}. It doesn't matter that this path segment was not included in the original request; only the output of the last routing is important. \\
            We switch our current directory to {\color{nbGreen}\texttt{/tasks}}. Is there a router file? There is, so let's create one object of this router.
         \item
            The function \lstinline!rewriteURL! is called with the URL relative to the router directory, so everything that was already routed is truncated. In other words: \\
            \lstinline!$router->rewriteURL(['edit', '1'], [], $stopRewriting);!.
         \item
            The URL is neither empty nor starts with ``add''. The router checks whether there is a parameter called ``task'', but our parameter array is empty. So the field \lstinline!$this->useParameters! is set to \lstinline!false!.  As we have a second entry in our URL (\lstinline!'1'!), the parameter array is changed to \lstinline!['task' => '1']! and the URL \lstinline!['edit']! is returned.
         \item
            We're done with the second level. Let's go to the next directory: {\color{nbBlue}\texttt{/tasks/edit}}. In this directory, we don't have a router file, so FIM simply takes the URL as path.
         \item
            We're done with the third level. There is no forth level (any more). Our URL was transformed to the path {\color{nbGreen}\texttt{/tasks/edit}} with one GET parameter: \texttt{task} equals \lstinline!'1'!.
      \end{itemize}
      The reverse process should also be clear by now; just keep in mind that FIM works outer-to-inner when transforming URLs to paths (so the outermost path is routed first) and inner-to-outer when transforming paths to URLs (so the innermost path is routed first)---it is a true ``reverse'' process. \\
      I want to point out the difference between static and dynamic routings once again, considering the most recent router file. If our path is empty ($\rightarrow$ list of tasks) or points to the add action, we return \lstinline!null!. This tells FIM that we will never, under no circumstances change these paths in this router file. So FIM can improve caching a lot and completely removes the call of this router. On the other hand, when we have a path to the edit action and even don't rewrite the path at the moment (because of \lstinline!$this->useParameters! is \lstinline!true!), we \emph{will} rewrite the path in certain circumstances (if the variable is \lstinline!false!). So we return the unchanged path array; now FIM knows that although no routing has been done, it cannot remove this router from the chain. That's the difference between static and dynamic routings and the reason why you need to clear the template cache whenever a static routing becomes dynamic (and you should do as well when a dynamic routing becomes static---this improves speed a lot).
   \subsection{Let's get international!}
      We have already made use of FIM's \lstinline!I18N! class to format dates. But this class can do much more, and that's what we will do now: We will add support for a second language to our project. \\
      This section requires changes in our templates and the module we have written so far. This is an issue that is due to the idea of this guide and a task you won't have to do in your real projects. You are highly encouraged to always use the capabilities of \lstinline!I18N! instead of hardcoding text in the templates (or even wore, as we did, in modules). If we had done this before, this section would not even be a whole page long, but this would have been too complex for the very beginnings with FIM. \\
      There are two archives that ship with this manual. The first one (\texttt{Tour1.zip}) ends before this chapter and contains the source of everything we have done so far. The second one, \texttt{Tour2.zip} contains the final, fully localized sources. \\
      We have to create a new directory in our CodeDir that is named \texttt{locales}. This directory will contain the ResourceBundle files used by FIM and the underlying International Component For Unicode (PHP's \texttt{intl} extension). We will then create a subfolder in the \texttt{locales} directory called \texttt{src} which will contain our language definitions. \\
      This subfolder will get a new file: \texttt{root.txt}. This manual will quickly summarize how the file is created with one example; you may copy the final file from the archive. \\
      We need to open a template that contains hardcoded strings. Let's start at the top level: \texttt{/base.tpl}. \\
      We will deal with the title string later. For now, we'll localize the strings ``My task list'', ``Home'' and ``All rights reserved.'' So our language file becomes:
      \begin{listing}[H]
         \caption{Localization of the base template, \texttt{//locales/src/root.txt}}
         \begin{minted}{resource}
root:table {
   base:table {
      appName:string { "My task list" }
      copyright:string { "All rights reserved." }
   }
   tasks:table {
      title:string { "Home" }
   }
}
         \end{minted}
      \end{listing}
      The occurrences of those strings in the template are then replaced by \smarty!{L ['base', 'appName']}! an so on. \\
      As a last step, we need to compile the language file to a ResourceBundle. For that, the tool \texttt{genrb} is needed which comes with the \href{http://site.icu-project.org/download}{\color{blue}International Components For Unicode} (ICU). Open the console and switch to the language source directory. The following command will create the compiled ResourceBundle:
      \texttt{genrb -d .. -e utf-8 root.txt}. We instruct \texttt{genrb} to take our source file and compile it, while the output directory shall be one level above the source. The encoding is set manually to UTF-8. This is important especially when there are characters beyond ASCII in the language file. \texttt{genrb} will recognize the correct encoding automatically, if a UTF-8 BOM is present in the language source files. While many editors support the creation of UTF-8 encoded files (you need one to create language files!), they often use UTF-8 without a BOM. In this case, the encoding has to be specified manually. \\
      After having executed the command line, a file name \texttt{root.res} will appear in the \texttt{locales} directory. Although we are only at the very beginning of localizing the whole application, you can already open the start page and see that nothing has changed, although you now called the language function instead of typing the string directly to the template. \\
      This didn't really justify the effort; but remember that adding new languages will become a very easy process by now. Furthermore, we can now get rid of the \lstinline!$title! variable. This was a nasty thing: By using a template system, FIM encourages the distinction between code logic and output. Titles are definitely part of the output and shall not be located in modules, which do the ``hard work''. \\
      We can now assign an module identifier instead of a title, which can then be used by the internationalization module to get a valid page title. But the best is that we don't have to assign this identifier, as FIM already did it for us. Every template knows of five variables that can be used to identify the module that executed the template:
      \begin{itemize}
         \item
            \lstinline!$__module! is a string that contains only the last part of the module folder. If the module is \texttt{/tasks/edit/fim.module.php}, this variable will be \lstinline!'edit'!.
         \item
            \lstinline!$__modulePath! is a string that contains the full FIM path of the module folder. The above example would be \lstinline!'//content/tasks/edit'!.
         \item
            \lstinline!$__modulePathArray! is an array that contains the FIM path items of the module folder: \lstinline!['content', 'tasks', 'edit']!.
         \item
            \lstinline!$__moduleResource! is a string that contains the FIM path relative to ResourceDir: \\ \lstinline!'/tasks/edit'!.
         \item
            \lstinline!$__moduleResourceArray! is an array that contains the FIM path items of the module folder relative to ResourceDir: \lstinline!['tasks', 'edit']!.
      \end{itemize}
      In our example, we will make use of the last variable. We will prepend one line to the base template: \\
      \smarty!{block name='title'}{$title = {L array_merge($__moduleResourceArray, ['title'])}}{/block}!. \\
      This allows us to remove the line that assigns a title to the template from every module; of course, we still have to add the titles to our language file. It will get a few new lines:
      \begin{minted}{resource}
root:table {
   base:table {
      appName:string { "My task list" }
      copyright:string { "All rights reserved." }
   }
   tasks:table {
      title:string { "Home" }

      add:table {
         title:string { "Add new task" }
      }

      delete:table {
         title:string { "Delete task" }
      }

      edit:table {
         title:string { "Edit task" }
      }
   }
   error:table {
      title:string { "Error {0,number} ({1})" }
   }
}
      \end{minted}
      We now need to recompile the file. If your operating system supports file locks, you will get an error when compiling the file with \texttt{genrb}: Access denied. This is due to the way ICU and \texttt{intl} handle ResourceBundles. A bundle that was once opened will stay open until the server shuts down. This is very convenient in production mode, as it accelerates the process of getting an entry from the bundle. However, in development, it might not please you that you have to restart your server whenever you add, change or remove language definitions. Such a restart is also necessary when you add a completely new locales, as the whole locales directory is cached, not only the files inside. \\
      So restart your server and recompile the file. You will see that although you removed the title assignment from every module, it is still correct in the output. \\
      We now have to further discuss the error page. You may have noticed that we put the title assignment in \smarty!{block}! tags, which allows us to overwrite them in other templates. This is what we need to do for the error page: First of all, our error title string does not follow the pattern of path-matching, as there is no module called \texttt{/error}. Second, our title changes with the error code---and we don't want to create a 64 different language strings for all possible HTTP error code (plus an unlimited number of user-defined codes). So we use ICU's capabilities of message parsing. Our error template needs a little modification:
      \begin{listing}[H]
         \caption{Changing the error template \texttt{/error.tpl}}
         \begin{smartycode}
{extends '/base.tpl'}
{block 'title'}{$title = {L ['error', 'title'] $errno Response::translateHTTPCode($errno)}}{/block}
{block 'body'}
   <p>An error has occurred.</p>
   <p><a href="{url '/tasks'}">Home</a></p>
{/block}
         \end{smartycode}
      \end{listing}
      Moreover, change the error module so that it assigns the value \lstinline!$errno! to the template instead of the title. \\
      When you now call an invalid URL, the error page will work as well. This looks very much like magic at the moment. Let's analyze, what we have done:
      \begin{itemize}
         \item
            Our error string contains two ICU placeholders, the first one being a number, the second one an arbitrary string. This is indicated with the braces around the parameter number. If you are using PHP~5.5 or above, this could be even nicer with named parameters: The language string might then look like \mintinline{resource}!"Error {errno,number} ({description})"!, which requires an adjustment in the language function (of which we will talk now).
         \item \label{tf2}
            The language template function can be called in two ways. The first one is shorthand syntax: The first parameter of the function is unnamed. This means that the language function will automatically call the method \lstinline!get! of the \lstinline!I18N! class. You may give an arbitrary number of additional parameters which the language function will automatically convert to an array and then pass as second parameter to the \lstinline!get! function. \\
            The second way to call the function was already introduced long before this chapter. It requires the first parameter to be named. The name of the parameter then indicates which function of the \lstinline!I18N! class shall be called. All following parameters will be passed as-it to the respective function without transformation. \\
            So the following two calls are identical: \\
            \smarty!{L ['error', 'title'] $errno Response::translateHTTPCode($errno)}! and \\
            \smarty!{L get=['error', 'title'] [$errno, Response::translateHTTPCode($errno)]}!.
         \item
            The \lstinline!I18N->get()! function expects one or two parameter(s). The first one (string or array) indicates the language identifier that shall be requested. If it is an array, every entry but the last one of this array shall be represented as tables in the ResourceBundle, while the last can be of any value. \\
            When the returned value is a string and you specify a second parameter, the ICU message formatter will then be called and do the appropriate replacements.
         \item
            As in PHP~5.5 named parameters are supported, we could also change the call of the template function to \\
            \smarty!{L ['error', 'title'] errno=$errno description=Response::translateHTTPCode($errno)}! with an adjusted language file.
      \end{itemize}
      The remaining process of internationalizing the application is quite boring; you can try it for yourself or copy the changed template and language files from the archive. \\
      I called it ``internationalization'' and not ``localization'' because in effect, we did not really change anything for the end-user so far. Our application is now ready to get a second locale. \\
      But before there is a second locale, we should create a first one---we didn't really do this so far. For details about how ICU handles ResourceBundles, it's worth reading the page \url{http://userguide.icu-project.org/locale/resources}. By creating a \texttt{root} resource, we assured that if everything else fails, the language keys from this file are used. But it is good style (and might prevent you from getting unexpected results\footnote{If your system's language is set to e.g.\ German and we will now add a locale file for German, the root resource will not be available any more, even if you explicitly tell FIM to use English. This is because the root resource is used only if neither the desired locale nor the system's default is available. As we didn't tell ICU that English is supported yet, ICU will always fall back to the system's default---i.e.\ German!}), to create a locale file for every supported locale. This locale file does not contain anything, as it takes its whole content from the root language:
      \begin{listing}[H]
         \caption{Our English dummy locale, \texttt{//locales/src/en.txt}}
         \begin{minted}{resource}
en {
}
         \end{minted}
      \end{listing}
      Compile this file; you will not get a ``file in use'' error message here, but the changes will not be detected unless you restart the server. This doesn't matter at the moment, as there were no real changes. \\
      Now we create the second locale by copying the \texttt{root.txt} file to \texttt{de.txt} and then translate every entry step-by-step. You might simply take the result from the archive. Restart the server and refresh our home. \\
      As you can see, you can see nothing. Our application is now bilingual, but the default locale is still set to English. We can for a check change FIM's default locale to German: Set the configuration entry \lstinline!'localeInternal' => 'de'!. When you now refresh the page, it immediately switches to German. \\
      That's fine, but we rather want the user to decide about the locale. There are several ways to do that. The most common approach would be to take the user's browser language. But if the user wishes to change the locale, this change has to be saved. We could make use of the Session class. This class is not explained in-depth in this document, but it's designed very straightforward. In short, it provides mechanisms to store information for multiple requests. It is an advanced wrapper around PHP's session mechanisms with support for flash items (those will only last until the very next module request). \\
      But the problem then is that one URL points to (at least) two different contents: one in English, one in German. This might not be a big deal, but it violates the concept of \emph{Unique} Resource Locators. \\
      Then we could add a GET parameter to the URL, containing the language. But this is nasty, we have to carry it with us with every single URL we create. \\
      We could also introduce a virtual directory at the top level that consists of the user's language. This would is the best approach so far, but it would indicate that the resources of different languages have nothing in common, which is certainly wrong. Furthermore, FIM generates absolute URLs with the URL function; those would still need to carry the locale folder with them (although FIM would take care of this). \\
      The recommended approach for this is to make use of subdomains. FIM provides intrinsic support for subdomains and automatically maps those to directories up to a level that is defined in your configuration. This directory can then be routed and the router sets the language. Subdomains will only appear in URLs when they change, so the language identifier will be kept away from template source.
   \subsection{Subdomains for language handling}
      At first, we'll play a little in the configuration. There are several keys that need to be changed. First of all, we want to activate FIM's subdomain handling. This is done by setting \lstinline!'subdomainDepth'! to \lstinline!1!, as we want our subdomains to be one level deep. We don't need to set \lstinline!'subdomainDefault'! for our use case. This setting would allow us to define a default path that is assumed when no subdomain is given. \\
      Now we need to specify \lstinline!'subdomainBase'!. This key is required when \lstinline!'subdomainDepth'! is greater than zero. FIM needs to know what our base URL looks like without any subdomains applied in order to determine the correct subdomain settings. If you run the application on a local server, this will most likely be \lstinline!'localhost'! (or if you use the server configuration as in \autoref{virtualHost}, \lstinline!'fim.localhost'!). If you want the application to be available via multiple domains, you may as well give an array of all the valid domains to this settings; FIM will automatically determine which one is currently used. \lstinline!'subdomainBaseError'! allows us to specify a PHP file which will be executed when the application was called with a domain that was not given in \lstinline!'subdomainBase'!. This file is included by FIM as a normal PHP script which is executed line-by-line. After the inclusion, FIM terminates. Note that neither database access nor session handling or routings work when this file is included. If this setting is not specified, a default error string is printed. \\ There is one important thing to note: FIM handles all URL transformations properly even if it is executed in a subdirectory. However, when used in subdomain mode, FIM \emph{has} to run as a first-level URL. This does not mean that you have to put your application in DocumentRoot, but you have to make sure that it can be accessed by a URL that does not contain a subfolder before your application. This can be achieved by setting a subdomain in your server's configuration that points to the directory your application is stored in. \\
      We have now set up FIM; you will still have to make sure that your server knows of these subdomains. The best thing would be to create a wildcard subdomain. In Apache, the following lines have to be appended to the configuration file:
      \begin{listing}[H]
         \caption{Modifying \texttt{httpd.conf}}
         \begin{minted}{apache}
<VirtualHost *:80>
   DocumentRoot "Insert the path to FIM here"
   ServerName fim.localhost
   ServerAlias *.fim.localhost
</VirtualHost>
         \end{minted}
         \label{virtualHost}
      \end{listing}
      If you work on localhost, your operating system will not be available to resolve the DNS \texttt{fim.localhost}. For that purpose, you either have to manually add every subdomain that is used to your hosts file (Windows), which will then look like this:
      \begin{listing}[H]
         \caption{Hosts file \texttt{\%windir\%\textbackslash system32\textbackslash drivers\textbackslash etc\textbackslash hosts}}
         \begin{minted}{text}
127.0.0.1 fim.localhost
127.0.0.1 en.fim.localhost
127.0.0.1 de.fim.localhost
         \end{minted}
      \end{listing}
      However, it would be much more comfortable if you install a DNS server such as Acrylic or use the DNS server delivered with your operating system (Linux), which both support wildcard host entries. You can then add the line \mintinline{text}!127.0.0.1 *.localhost! to the hosts file (or whatever is required to configure your DNS software) and will be happy for all languages. But this is only an issue if you work locally; if you have a registered domain, simply enable wildcard subdomains for this domain (if available). \\
      The next task is to modify our top router so that our application regains functionality:
      \begin{listing}[H]
         \caption{Modified main router \texttt{/fim.router.php}}
         \phpfile{demo/content/fim.router.php}
      \end{listing}
      Now refresh the page in your browser (note that depending on which settings you used above, the URL may have changed to \texttt{http://fim.localhost}). You will be immediately redirected to either \texttt{http://en.fim.localhost} or \texttt{http://de.fim.localhost}, depending on the language of your browser. If your browser has a different language, ICU and FIM will determine a best-fit to which you will be redirected. You may now manually change the URL to the other one and the whole application changes its locale. \\
      There is one last thing missing regarding the topic of localization: The user should see which languages are supported and it should not be necessary to change the URL manually. Instead, we want to provide flags in the header of each page that allow to change the current page to a different language immediately. \\
      As the buttons shall be visible on each page, we will only edit our main template \texttt{/base.tpl}. Within the navigation bar, after our \smarty!<ul>!, we will insert these lines: \enlargethispage{.7cm}
      \begin{listing}[H]
         \caption{Providing a language switcher}
         \smartyfile[firstline=38,lastline=56,firstnumber=38,gobble=15]
                    {demo/content/base.tpl}
      \end{listing}
      Most of these are simple design elements. What matters is---once again---how methods of the current locale object are retrieved. This is done by using the \texttt{L} template function in its long (explicit) form and using the first key as method name. Even if the method that needs to be called doesn't expect any parameter, we will have to give one so that FIM can notice that this is not shorthand syntax; that's why we pass \lstinline!null!. \\
      The other interesting thing is the \lstinline!i18nURL! function. This functions allows to iterate through all available locales, languages, regions or scripts (depending on the first parameter). For every item, the URL function will be applied to a given URL (or multiple ones), which is given as second parameter. If the second parameter is omitted, the current URL will be used. For details, see the function's documentation.---It should be noted that the results of this function cannot be cached, so it is not terribly fast. If you build applications that expect lots of requests per second, it might be worth the effort to retrieve the menu of available languages via AJAX instead of embedding it in every template. \\
      If you refresh the page, you will now notice the ``Change language'' button at the top right edge.
   \subsection{Rules} \label{rules}
      This will be the last big section in our demo application. We did not make use of FIM's rule system yet---we did not require any authentication! This will change by now. \\
      We will design a very simple authentication mechanism without a user table or something similar. It is left as an exercise to you to create a table in the database that contains users with passwords, write a proper table class and then change the implementation below to use this class. This whole process should not require more than five minutes. \\
      We will now create a rules file. There are basically two ways for this: First, FIM allows us to create a rules file by overriding the \lstinline!\Rules! base class. This allows us to use PHP's full capabilities, but maybe we only want to create basic rules which aren't worth creating a whole class. For this purpose, FIM also allows to make use of its rules text files. Those files are written in an INI-like format that is parsed by FIM and only focuses on the rules itself, omitting all unnecessary PHP syntax. \\
      The only rule that is needed is very simple, we will therefore use the text syntax. The same functionality can be accomplished by using the more verbose syntax which is printed at the end of this chapter for your information. \\
      Create the file \texttt{fim.rules.txt} in the folder \texttt{/tasks}:
      \begin{listing}[H]
         \caption{\texttt{/tasks/fim.rules.txt}}
         \inputminted{fimrule}{demo/content/tasks/fim.rules.txt}
      \end{listing}
      This simple file will be responsible for denying access for all modules that perform actions. The first line defines the section that is controlled. This can be one of \fimrule![EXISTENCE]!, \fimrule![READING]! or \fimrule![LISTING]!. The section defines the state in which accessing a resource will fail or succeed. \fimrule![EXISTENCE]! means that FIM will proclaim that the resource does not even exist (404), \fimrule![READING]! will issue an ``Unauthorized'' error (401) while \fimrule![LISTING]! allows to control the availability of directory listings at a level that is far more specific than the configuration directive. \\
      The second line assigns the value \lstinline!0! to the result of the rules evaluation process, if the condition right to the equal sign fits. What does this value mean? \\
      FIM will---once again---iterate through the different directories (from general to specific, top-to-bottom) and evaluate every rule that might have an effect on the current resource. The rule function may return one of the following values:
      \begin{itemize}
         \item \lstinline!int! (or \lstinline!null!, which will equal to \lstinline!0!) \\
            Positive values indicate granted access, negative values denied access. Zero will not change the current state. \\
            Values that are bigger in its absolute value will overwrite absolute smaller ones. This allows to be far more precise in terms of overwriting than with the base rules ``more specific rules overwrite less specific ones''. As FIM cannot determine which rule really \emph{is} specific, the absolute value will serve as hint. Only if two values are absolute-identical, rules of a deeper level will overwrite those of the more general one.
         \item \lstinline!false! \\
            This value will immediately deny access to the resource. No further rules are checked.
         \item \lstinline!true! \\
            This value can be interpreted as ``the biggest integer''. It will allow access to the resource and can only be overwritten by \lstinline!false!.
      \end{itemize}
      If the result after the evaluation process is zero, FIM will decide whether to allow access by using the configuration setting \lstinline!'defaultAccessGranted'! (for \fimrule![EXISTENCE]! and \fimrule![READING]!) or \lstinline!'directoryListing'! (for \fimrule![LISTING]!). \\
      Now we know the meaning of \lstinline!0!, but what is meant with \texttt{=E}? This tells FIM that the value that follows the equal-E sign has to be evaluated by PHP. The whitespaces are only for clarification and not necessary. The variables \lstinline!$fileName!, \lstinline!$fullName! and \lstinline!$file! will be available to get the basename or the complete FIM-normalized filename (rules will only be called for files or folders that are directly in the folder of the rule file itself, so the process of recursive iteration will only iterate through directory names). The capital \texttt{E} defines \lstinline!$file! to be identical with \lstinline!$fileName! while a small \texttt{e} would make it identical to \lstinline!$fullName!. \\
      The distinction between capital and small is especially important when you use the other means of comparison. Instead of \texttt{=E}, you might also write
      \begin{itemize}
         \item
            \texttt{=R} or \texttt{=r}, which will apply a PCRE regular expression to the \lstinline!$file! variable. \\
            Example: \fimrule!false =R /^secure.*$/i! %$
         \item
            \texttt{=C} or \texttt{=c}, which will do a literal comparison with the \lstinline!$file! variable. \\
            Example: \fimrule!false =C secureContent!
      \end{itemize}
      Furthermore, there is the possibility to write \fimrule!match! on the left side of the equal sign. Only the modes \texttt{=E} and \texttt{=R} (and their small counterparts) are available. Every following line that is indented will be evaluated as PHP code, while the variable \lstinline!$match! contains the matches of the regular expression if the mode was \texttt{=R} or the result of the PHP expression if the mode was \texttt{=E}. Example:
      \begin{minted}{fimrule}
match =R /^(in)secure.*$/i
 1 = isset($match[1])
 -1
      \end{minted}
      There are still two features of text rules missing: The directive \fimrule!clone=...! will copy the rules of the section \texttt{...} to the current section. And finally, you may simply specify an integer or boolean in a line without an equal sign, which will make this the default return value. As evaluation stops as soon as the first expression fits, this should only be used in the last line of a section. This syntax can also be used in \texttt{match} items, but it is \emph{required} to be the last one here. \\
      Now we know what is done in our rules file: If the current filename is \texttt{.}---this means that the directory of the rules file is accessed directly, i.e.\ \texttt{//content/tasks}---or if our session tells us to do so, we will not deny access; in any other case, we will do. \\
      When you now refresh the page, you'll see that only the listing is available; any navigation will lead to a 401 error. \\
      We want to change this error to a login form. This is very easy; we will add error handling capabilities to the \texttt{tasks} module. So create this function:
      \begin{listing}[H]
         \caption{Error handler in \texttt{/tasks/fim.module.php}}
         \begin{phpcode*}{startinline}
   public function handleError401() {
      if(\Request::isPost()) {
         if(\Request::post('password') === 'admin') {
            \Session::set('authenticated', true);
            \Request::restoreURL();
            return;
         }else
            $this->failed = true;
      }else
         \Request::saveURL();
      $this->displayTemplate('login.tpl');
   }
         \end{phpcode*}
      \end{listing}
      The \lstinline!\Request::restoreURI()! and \lstinline!\Request::saveURL()! functions are responsible for storing and retrieving the current URL so that the user is redirected to where they was before receiving an error. As we implemented the error handler without redirection to any login page (which would be a far more convenient way and is left to your exercise), this is not really necessary in our case. You may take the required template from the archive. \\
      As a last part of this section, I will shortly present the rules file in PHP mode:
      \begin{listing}[H]
         \caption{Alternative rules file: \texttt{/tasks/fim.rules.php}}
         \begin{phpcode}
<?php

namespace content\tasks;

class Rules extends \Rules {

   public function checkReading($fileName, $fullName) {
      if($fileName !== '.' && !\Session::get('authenticated'))
         return false;
   }
}
         \end{phpcode}
      \end{listing}
      And for a very last part, I will only show a short excerpt to FIM's Autoboxing which relies on doccomments by providing the rules function with a third parameter that will automatically be retrieved from the session variable and thus eliminates the call of the get function:
      \begin{listing}[H]
         \caption{Alternative rules file (2): \texttt{/tasks/fim.rules.php}}
         \begin{phpcode*}{frame=topline}
<?php

namespace content\tasks;

class Rules extends \Rules {
         \end{phpcode*}
      \end{listing}
      \begin{phpcode*}{firstnumber=6,frame=bottomline,startinline}
   /**
    * @param string $fileName
    * @param string $fullName
    * @param bool $authenticated session
    */
   public function checkReading($fileName, $fullName, $authenticated) {
      if($fileName !== '.' && !$authenticated)
         return false;
   }
}
      \end{phpcode*}
      Now \lstinline!$authenticated! is guaranteed to be a boolean value that comes from the session variable of this name. \\
      Our demo application of course lacks a logout page, it should get a proper login page to which is redirected instead of changing the original page's purpose. Users might be backed in the database and so on. By the end of this chapter, you should be able to perform these tasks by yourself in a few minutes.
   \section{Reference}
      This section will explain the individual functions of FIM classes that are available in public namespace in an alphabetical order of the file they're located in.
   \subsection{Autoboxing}
      Any function or method can be autoboxed by FIM, including closures (but not functions created with \lstinline!create_function!). Autoboxing will try to guess the values of the parameters that shall be given to the function. For this, a function can either indicate the type of its parameter with typehints or use PHPDoc. The doccomment for the function should have the following structure.
      \begin{phpcode*}{startinline}
/**
 * @param <type> $<name> [<source>[:<source name>]] [<comment>]
 * <repeat>
 */
      \end{phpcode*}
      \begin{itemize}
         \item \texttt{<type>} \\
            This will indicate of which type the parameter has to be. It can be any of PHP's primitive types; in this case, the parameter will be casted to this type. It might also be the name of a class that implements the \lstinline!Autoboxable! interface. It is possible to allow \lstinline!null! by specifying it as an alternative type using a pipe. \\
            Arrays with entries of a certain type are possible as well (but only one-dimensional arrays). The type has to be followed by an opening and a closing square bracket; if the type contains alternatives, it has to be enclosed in brackets: \texttt{(ClassName|null)[]}.
         \item \texttt{<name>} \\
            This is the name of the parameter, exactly as given in the function definition.
         \item \texttt{<source>} \\
            You might specify one of the following keys as indicator where FIM should get the value for the parameter from: \texttt{param} (requires the parameter to be given to the autoboxing function), \texttt{get} (\lstinline!Request::get!), \texttt{post} (\lstinline!Request::post!), \texttt{session} (\lstinline!Session::get!), \texttt{file}/\texttt{filestream} (\lstinline!Request::getFileResource!) or \texttt{filestring} (\lstinline!Request::getFileContent!). It is also possible to use a chunk of PHP code here if you need complete freeness in where to get the source from (in this case, \texttt{<source name>} and \texttt{<comment>} must not be given\footnote{It is however possible to define a ``comment'' by using PHP's line comment delimiters \lstinline!#! or \lstinline!//!. Note that you have to repeat this delimiter in every new line if you wish multi-line comments.}): \lstinline!/** @param int $name \Session::get('user')->name */!. \\
            This field might be left out; in this case, the value is taken from the parameter if available or from \lstinline!Request::get! if not. This behavior can be copied by specifying \texttt{param} as an alternative. \\
            Note that this parameter is \emph{required} if any of the following elements are given!
         \item \texttt{<source name>} \\
            If this field is given, the name that is passed to the source function will not be the parameter's name but the one given here instead. Note that source names are always case sensitive!
         \item \texttt{<comment>} \\
            You might give a description for the parameter that contains any character until another PHPDoc element begins.
         \item \texttt{<repeat>} \\
            The above structure can be given for any parameter of the function. It is however only required for a parameter if you want to change the default behavior \texttt{mixed param|get}. But as doccomments are also (or mainly) used for documentation purposes, it is highly recommended that you specify every parameter that is used in the function.
      \end{itemize}
      \paragraph{Calling a function}
         It is normally not necessary to call autoboxing functions by yourself as the \lstinline!execute! function of every module is called using autoboxing (including forwarded calls). But you might wish to make use of one of those two class methods:
         \begin{itemize}
            \item \lstinline!Autoboxing::callMethod($class, $name, array $arguments = [])! \\
               This method is intended to call a method of a class or object using autoboxing. If a static method shall be called, the first parameter must equal the class name; if an object method is to be called, set \lstinline!$class! to the object. \\
               \lstinline!$name! is a string that contains the name of the method. \\
               \lstinline!$arguments! is an optional associative array that shall be filled with parameters that can be passed to the function if they are required. \\
               The return value will equal the function's return value.
            \item \lstinline!Autoboxing::callFunction(callable $function, array $arguments = [])! \\
               This method can be used when a closure or function---which has to be given as first parameter---should be called. The \lstinline!$arguments! parameter is as in the function above.
         \end{itemize}
      \paragraph{Autoboxable}
         Classes that implement this interface can be used as typehint or PHPDoc type. The static method \lstinline!unbox! will be called with exactly one parameter which is a string. The function's return value will be used as parameter value. Note that FIM will only check whether the return value actually is of the type that it should be if you also specify a typehint!
      \paragraph{Implementation remarks}
         \begin{itemize}
            \item
               Calling a function or method with autoboxing generates a cache file in the \texttt{//cache/autoboxing} directory. Each PHP source file will create an own cache file; moreover, autoboxing for functions will also create its own cache file.
            \item
               It is not possible to apply autoboxing to PHP's or FIM's internal functions.
            \item
               An autoboxing parameter must not be of the type \texttt{callable} or be passed by reference.
            \item
               While FIM can handle autoboxing for closures, those that only comprise one single line, all start and end in the same line, have the same number of (required) parameters \emph{and} the same doccomments cannot be distinguished by autoboxing. This should not be a problem for those who use proper code formatting.
            \item
               Autoboxing will only work for public functions. As the calling context changes, this is a drawback that has to be taken in account\footnote{It would theoretically be possible to overcome this problem. However, determining the original calling context and switching to it would waste resources.}.
            \item
               Autoboxing supports inheritance. If a function is not present in the current object, it will look for its implementation in superclasses. Note that the function has to be public there as well! At the moment, PHPDocs have to be repeated if a function is overwritten, there is no support for the (yet unofficial) \lstinline!/** {@inheritDoc} */! directive.
            \item
               An \lstinline!AutoboxingException! will be thrown if autoboxing failed either during the function call or while preparing the cache.
         \end{itemize}
   \subsection{Config}
      FIM provides access to its configuration via the \lstinline!Config! class. The \lstinline!Config::get($key)! function retrieves the value of the configuration entry \lstinline!$key! while the function \lstinline!Config::equals($key, ...$value)! checks if the entry \lstinline!$key! is strictly equal to at least one of the values given in \lstinline!$value!. The method \lstinline!Config::set($key, $value)! changes FIM's configuration by setting the entry \lstinline!$key! to the new value \lstinline!$value!. Note that some configuration settings can only be set in the initial configuration in the controller by passing them as an entry in an associative array to \lstinline!fimInitialize()!. \\
      The \lstinline!Config! class provides three functions that provide further functionality:
      \begin{itemize}
         \item \lstinline!Config::registerShutdownFunction(callable $callback[, ...$parameter])! \\
            This function will register the function, method or closure that is given in its first parameter as a shutdown function (which will receive all the parameters that can be passed as further arguments here). These functions will be executed at the very end of the script, even if PHP halts unexpectedly. While this function is identical in what it does to PHP's internal function \lstinline!register_shutdown_function!, it returns an identifier that can be used to unregister the function.
         \item \lstinline!Config::unregisterShutdownFunction($id)! \\
            This function will remove the callable that was registered as a shutdown function from the chain. It expects the return value of \lstinline!Config::registerShutdownFunction! as parameter.
         \item \lstinline!Config::iniGet($key)! \\
            This function behaves exactly as PHP's internal function \lstinline!ini_get! with the difference that numbers are recognized automatically, including the suffixes \texttt{K}, \texttt{M} and \texttt{G}. The return value will be an integer in this case.
      \end{itemize}
      \paragraph{Configuration entries}
         This section will give you an overview of the different configuration entries of FIM. While all these can be passed to the initialization function \lstinline!fimInitialize!, some entries cannot be changed by using \lstinline!Config::set!. Possible values are given in square brackets; the first value is the default.
         \begin{itemize}
            \item \lstinline!'autoEscape'! [\lstinline!true!|\lstinline!false!] \\
               Determines whether Smarty uses automatic escaping of all variables or functions.
            \item \lstinline!'cliServer'! [\lstinline!'CLI'!|\lstinline!string!] \\
               The constant \lstinline!Server! will contain the name of the server that was used to fetch the content (e.g.\ \texttt{example.com} if the URL was \texttt{http://en.example.com/admin/}). If FIM is used in client mode, there is no such thing as a ``server'', so the constant will be set to the value of this setting. \\
               If the default value is not changed but at least one entry in the setting \lstinline!'subdomainBase'! exists, FIM will take this entry's value.
            \item \lstinline!'defaultAccessGranted'! [\lstinline!true!|\lstinline!false!] \\
               Defines whether \texttt{READING} or \texttt{EXISTENCE} access is granted to any resource for which there are no further rules.
            \item \lstinline!'directoryListing'! [\lstinline!'development'!|\lstinline!'simple'!|\lstinline!'detail'!|\lstinline!'none'!] \\
               Specifies the level of detail for directory listings. Simple directory listings will only show the names of files and directories while detailed ones will include information about size and dates. \lstinline!'none'! disables directory listing if no further rules explicitly allow it. \lstinline!'development'! equals to \lstinline!'detail'! in development mode and to \lstinline!'none'! in production mode (when getting the value, \lstinline!'development'! will never be returned but the value it was dynamically set to instead). \\
               If directory listing is set to \lstinline!'none'! and allowed in a certain folder by rules, the display mode will be simple. If you wish detailed information instead, you have to set this value to \lstinline!'detail'! and generally forbid directory listing by issuing a negative value in the very top level rules file.
            \item \lstinline!'defaultEncoding'! [\lstinline!'utf-8'!|\lstinline!'string'!] \\
               Sets the encoding that is issued by default in the \texttt{Content-Type} HTTP header. You may change this encoding for individual files by calling \\
               \lstinline!Response::set('Content-Type', '...; charset=...');!.
            \item \lstinline!'localeRawFallback'! [\lstinline!false!|\lstinline!true!] \\
               FIM favors the concept of language keys, i.e.\ a language entry in the locales file has a unique key identifier and a---in most cases---different value. If a language key was not found, FIM will report this error to the log and generate a dummy output which consists of the key with appended parameters. \\
               It is however possible to instruct FIM to use the key as a last fallback language entry instead by changing this setting to \lstinline!true!. This means that the key itself is used and passed to the message formatter if no entry in the language was found. Note that this approach is not favorable with ICU and that you might run into problems with special characters or long key names (future versions of ICU may limit the maximum number of characters for keys). \\
               Note that this value cannot be changed with the \lstinline!Config::set! method.
            \item \lstinline!'localeInternal'! [\lstinline!'en'!|\lstinline!string!] \\
               Defines the locale that FIM uses for its internal messages. This includes error messages as well as e.g.\ headers in the directory listing. This locale will also be the default one for the application's locale. While the latter one can be changed by using \lstinline!I18N::setLocale!, changing FIM's internal locale is not possible after initialization.
            \item \lstinline!'mailErrorsTo'! [\lstinline!false!|\lstinline!string!] \\
               Any error that is reported in a log will be mailed to the address given here. Mailing can be disabled for individual messages or generally by setting this value to \lstinline!false!.
            \item \lstinline!'mailFrom'! [\lstinline!'Framework <noreply@framework.log>'!|\lstinline!string!] \\
               You may specify the value that should be passed in the \texttt{From:} mail header. Note that a specific value might be required here by your provider. This value is the default for all mails that are sent with the \lstinline!PHPMailer! class that is delivered with FIM but can be overwritten for every single mail.
            \item \lstinline!'memcachedConnection'! [\lstinline![]!|\lstinline!(string|[string, int]|[string, int, int])[]!] \\
               The property \lstinline!Session::$memcached! provides a \lstinline!Memcached! object which will automatically connect to the server(s) as specified in this setting. Note that while the setting has to be an array, it can have various substructures. A string will default to the port \lstinline!11211!, a two-entry array defines host and port, a three-entry array sets host, port and weight. \\
               Note that FIM will always provide an interface in the \lstinline!Session::$memcached! property that has the same methods available as PHP's Memcached extension, even if the extension is not installed or only the older Memcache. However, real support for multiple servers is only possible when the new extension is installed (or FIM will connect to the weightiest server instead). \\
               Changing this value is not possible. If changes are necessary, they can be applied to the object itself.
            \item \lstinline!'plugins'! [\lstinline![]!|\lstinline!string[]!] \\
               A plugin is any kind of external script that is required by your application. In order to be available for autoloading, these scripts have to follow FIM's naming convention: The namespace must equal the directory while the classname is equal to the filename minus the extension \texttt{.php} (note case sensitivity on most file systems---always use the same spelling for your class names although PHP is case insensitive!). Any plugin is required to be stored in a subfolder of \texttt{//plugins}. \\
               If there is third-party code that does not follow these naming conventions, it is possible to tell FIM where to look for the file by specifying an entry in this configuration array. The key must equal the class name while the value is a FIM path that specifies the location of the source files. Relative paths will start in the \texttt{//plugins} directory. Note that this is the only place where it is possible to use PHP's include path with FIM. You may prepend the filename with a hash sign (\texttt{\#}). This will instruct FIM to pass the path following this character exactly as given to PHP's \lstinline!require! function. \\
               It is not possible to use autoloading for functions. If your third-party plugin does not provide a class but only a set of functions, it's your responsibility to include the necessary files by yourself.
            \item \lstinline!'production'! [\lstinline!false!|\lstinline!true!] \\
               This is the main switch for changing between development and production mode. In development mode, sensitive information is directly echoed in the browser or console to the user for debugging purposes. This can greatly improve the process of development. However, in production mode, this information is only written to the log which allows e.g.\ to analyze errors, but does not reveal anything about the internal structure to the end user.
            \item \lstinline!'redisConnection'! [\lstinline!null!|\lstinline!mixed!] \\
               The property \lstinline!Session::$redis! provides an interface to Redis. If the PHP extension \texttt{Redis} is available, FIM will make use of this and the property will contain an instance of \lstinline!RedisArray!, which is instantiated with this setting as first parameter and the configuration entry \lstinline!'redisOptions'! as second. If the extension is not available though you want to use Redis, copy the Predis library files from the \texttt{src} folder of the \href{https://github.com/nrk/predis}{\color{blue}archive} to the \texttt{//plugins/Predis} folder. As this library matches FIM's naming conventions, it does not have to be registered with the \lstinline!'plugins'! setting. The property \lstinline!Session::$redis! will then be an instance of \lstinline!Predis\Client!, instantiated as above. \\
               It is not possible to change this setting. If changes are necessary, they can be applied to the object itself.
            \item \lstinline!'redisOptions'! [\lstinline!null!|\lstinline!mixed!] \\
               See \lstinline!'redisConnection'!. \\
               It is not possible to change this setting.
            \item \lstinline!'requireSecure'! [\lstinline!false!|\lstinline!true!] \\
               Defines whether FIM will take care that the application is only invoked with the HTTPS protocol. Any call with HTTP will be redirected to the appropriate HTTPS page.
            \item \lstinline!'sessionLifetime'! [\lstinline!300!|\lstinline!int!] \\
               In order to make session hijacking harder, FIM provides this mechanism which will invalidate the current session after the given amount of seconds. A new session id will be generated and sent to the user. In order to prevent session loss, the invalidated session will still be accessible for the client for number of seconds that can be defined in the setting \lstinline!'sessionTransition'!. \\
               Set this value to zero to disable this feature. \\
               Negative values and those from \lstinline!1! to \lstinline!9! are prohibited (but you should not use too small values anyway).
            \item \lstinline!'sessionStorage'! [\lstinline!'default'!|\lstinline!'memcached'!|\lstinline!'redis'!] \\
               By default, FIM uses PHP's integrated session storage mechanism which will save sessions to files. For speed reasons, this is not to be considered optimal. You may change the behavior to use one of the two caches that FIM intrinsically supports. Note that the option \lstinline!'memcachedConnection'! or \lstinline!'redisConnection'! has to be set (depending on which storage engine you wish to use).
            \item \lstinline!'sessionTransition'! [\lstinline!5!|\lstinline!int!] \\
               Defines the amount of seconds for which an old session id is still valid after it has been changed with \lstinline!Session::renewId! or automatically via the \lstinline!'sessionLifetime'! setting. This prevents nearly simultaneous requests from invalidating each other. If your application shall be optimized for especially slow connections, higher values are recommended. Zero will disable a transition time, which is generally not favorable. \\
               This value's range is from zero to the value of \lstinline!'sessionLifetime'! (or \lstinline!PHP_INT_MAX!, if this setting is zero). Equal values mean that a whole session id renewal can be skipped by a client.
            \item \lstinline!'subdomainBase'! [\lstinline!''!|\lstinline!string!|\lstinline!string[]!] \\
               This setting allows FIM to determine which part of the URL is the constant server and which belongs to the subdomains. This setting is required when \lstinline!'subdomainDepth'! unequals zero. \\
               If the application can be called with the URLs \texttt{http://*.super.com} and \texttt{http://*.super.net}, this setting is expected to be set to \lstinline!['super.com', 'super.net']!.
            \item \lstinline!'subdomainBaseError'! [\lstinline!''!|\lstinline!string!] \\
               Defines a valid FIM path of a PHP file that will be invoked if the application is called with a URL that fits to none of the given servers in \lstinline!'subdomainBase'!. This PHP file will be included directly and shall present an error message to the user. After the execution of this file FIM will immediately halt. If no file is present when such an error occurs, FIM will throw a configuration exception. \\
               Note that FIM's initialization could not be completed when this file is included. Therefore, you must not make use of any database function, access the Memcached or Redis object or use methods of the class \lstinline!Router! that have to do with URL conversion. You might use functions of the \lstinline!Response! class instead of echoing directly, but keep in mind to call \lstinline!Response::doSend! at the end of your error script.
            \item \lstinline!'subdomainDefault'! [\lstinline!''!|\lstinline!'string'!] \\
               If FIM does not detect any subdomain although \lstinline!'subdomainDepth'! is greater than zero, this string will be taken as a default subdomain. Note that you can prevent the user to access certain folders by enforcing a default subdomain! The \texttt{//content} directory will not be available any more if a subdomain default is given. If the default contains multiple levels, even more directories will not be accessible to the user.
            \item \lstinline!'subdomainDepth'! [\lstinline!0!|\lstinline!int!] \\
               This settings defines how many subdomains can be passed as a maximum. Subdomains will be implicitly rewritten to directories. The constant \lstinline!CurrentSubdomain! is available to get the string that was used as a subdomain.
            \item \lstinline!'x-sendfile'! [\lstinline!'auto'!|\lstinline!'apache'!|\lstinline!'cherokee'!|\lstinline!'lighttpd'!|\lstinline!'nginx'!|\lstinline!'none'!] \\
               X-Sendfile or X-Accel-Redirect is a module that has to be installed and/or activated in your server software. It is used to deliver raw files very resource-efficient. With \lstinline!'auto'!, FIM will automatically determine the server software that is used. If you don't have this module enabled, you need to manually set this value to \lstinline!'none'!, as FIM can't detect a disabled module. \\
               Note that you need to configure nginx specially for use with FIM. By enabling the \texttt{mod\_rewrite} equivalent in nginx, the X-Accel-Redirect technology is also affected. Thus, you need to provide a virtual location that is named \texttt{fim.InternalGetContent} which will link to CodeDir. The server configuration file might look similar to this (replace \texttt{<path to FIM>} accordingly): \label{nginx}
               \begin{minted}{nginx}
http {
   sendfile on;

   server {
      listen 80;
      server_name fim.localhost;
      root <path to FIM>;

      location ^~ /fim\.InternalGetContent/ {
         internal;
         alias <path to FIM>;
      }

      location / {
         try_files $uri /index.php;
      }

      location ~ \.php$ {
         fastcgi_pass  127.0.0.1:9000;
         fastcgi_index index.php;
         fastcgi_param SCRIPT_FILENAME <path to fim>/$fastcgi_script_name;
         include       fastcgi_params;
      }
   }
}
               \end{minted}
         \end{itemize}
   \subsection{Database}
      The database class is responsible for parsing connection files. The only function that might be of interest is \lstinline!Database::getActiveConnection($require = true)!, which will return the instance of the activated \lstinline!DatabaseConnection! object. If the first parameter is \lstinline!true!, an exception will be raised when there is no connection; else \lstinline!null! will be returned. The necessary database connection will automatically be activated when a module is executed. \\
      Connection files (\texttt{fim.database.txt}) contain the parameters that specify a database connection. They will take effect for the folder they're located in and potentially for all subfolders. Their format is an INI-like structure (\texttt{key=value}), but without sections. The following keys exist (possible values in square brackets, default underlined):
      \begin{itemize}
         \item \texttt{recursive} [\underline{\texttt{true}}|\texttt{false}] \\
            If this value is \texttt{true}, the settings in this file will also apply for each subdirectory if they are not overwritten there.
         \item \texttt{driver} [\texttt{4d}|\texttt{cubrid}|\texttt{dblib}\texttt{firebird}|\texttt{ibm}|\texttt{informix}|\texttt{mssql}|\texttt{mysql}|\texttt{oracle}|\texttt{odbc}| \\ \texttt{pgsql}|\texttt{sqlite}|\texttt{sqlsrv}|\texttt{sybase}] \\
            The string that is given here will define the driver PDO uses to establish a connection. If you sometime decide to switch to a different driver and stuck to SQL standard in your queries, no changes shall be required. Some drivers provide proprietary commands; if you use them, FIM can't help you when changing the driver. Other drivers use e.g.\ different types of escape symbols (SQL standard defines~\verb!"! as column name delimiter while MySQL uses~\verb!`!). Those specialties can normally be changed and FIM will take measures to make the engines as much standard-compliant as possible (so MySQL will also use \verb!"! as column name delimiter).
         \item \texttt{host} [any string] \\
            Defines the host PDO will connect to. Can be used with the drivers \texttt{4d}, \texttt{cubrid}, \texttt{dblib}, \texttt{ibm}, \texttt{informix}, \texttt{mssql}, \texttt{mysql}, \texttt{oracle}, \texttt{pgsql}, \texttt{sqlsrv}, \texttt{sybase}. Note that some drivers may be slow while establishing the connection if you use hostnames (\texttt{localhost}) instead of IPs (\texttt{127.0.0.1}).
         \item \texttt{port} [any valid port number, \underline{default port if available}] \\
            Defines the port PDO will connect to. Can be used with the drivers \texttt{4d}, \texttt{cubrid}, \texttt{dblib}, \texttt{ibm}, \texttt{informix}, \texttt{mssql}, \texttt{mysql}, \texttt{oracle}, \texttt{pgsql}, \texttt{sqlsrv}, \texttt{sybase}.
         \item \texttt{database} [any string] \\
            Sets the database name. For SQLite a FIM path is required (but do not use relative paths!) or \texttt{:memory:}.
         \item \texttt{dsn} [any valid DSN string] \\
            PDO uses DSN strings to establish a connection. FIM uses the above settings to compute the DSN automatically. If you however need to define a DSN manually, this settings will \emph{overwrite} all the above values of \texttt{driver}, \texttt{host}, \texttt{port} and \texttt{database}. FIM will not change the DSN in any way. For SQLite this means that you need to provide a filesystem absolute path. ODBC driver requires to use this setting. \\
            Note: This value will also be inherited if \texttt{recursive} is not set to \texttt{false} and will thus take precedence over the above values in any connection file in a subfolder. It has to be invalidated with \texttt{dsn=}.
         \item \texttt{user} [any string] \\
            Specifies the user name; might not be required.
         \item \texttt{password} [any string] \\
            Specifies the password; might not be required.
         \item \texttt{persistent} [\texttt{true}|\underline{\texttt{false}}] \\
            Defines whether the database connection stays open after the current request has finished. Unless you are using ODBC, turning on this setting can improve speed and help to reduce overhead.
      \end{itemize}
   \subsection{Database connection}
      A database connection is represented in FIM as an instance of the class \lstinline!DatabaseConnection!. This class provides some methods for establishing and closing a connection, which should not be called by you. Those methods are not listed in the following explanation and not commented in the source. \\
      The other methods of this class provide means to control database functions. You can access the active database connection object with \lstinline!Database::getActiveConnection!.
      \begin{itemize}
         \item \lstinline!DatabaseConnection->getConnection()! \\
            Returns the instance of the \lstinline!PDO! class that lies behind this connection object. If the following helper functions do not suffice, you may use this object directly.
         \item \lstinline!DatabaseConnection->enterTransaction()! \\
            Starts a transaction. Nested transactions are supported if the database driver supports the \mysql!SAVEPOINT! directive.
         \item \lstinline!DatabaseConnection->leaveTransaction($commit = true)! \\
            Leaves a (nested) transaction. Depending on the parameter, the operations are either committed or reverted.
         \item \lstinline!DatabaseConnection->execute(PDOStatement $stmt, array $values = [])! \\
            This is a helper function that automatically binds given values to a PDO statement that was created with the \lstinline!PDO->prepare! method. The \lstinline!$values! array is either associative or numeric, depending on whether named or unnamed parameters were used. FIM will automatically determine the necessary binding type by inspecting the value's type. If you wish to pass BLOB data, pass an instance of \lstinline!Blob! as value (but see the remarks at the end of this subsection).
         \item \lstinline!DatabaseConnection->select($from, $where = null, array $bind = null, array $columns = [], $order_by = null,! \\ \lstinline!   $group_by_having = null, $limit = null, $join = '', $force_statement = false)! \\
            Executes a select statement. The parameters are documented in the PHPDoc.
         \item \lstinline!DatabaseConnection->insert($into, array $columnValues)! \\
            Performs an insert statement and takes care of escaping the values.
         \item \lstinline!DatabaseConnection->update($table, array $newValues, $where = null, array $bind = null)! \\
            Updates entries in a table that match the given conditions.
         \item \lstinline!DatabaseConnection->delete($from, $where = null, $bind = null)! \\
            Removes entries from a table that match the given conditions.
         \item \lstinline!DatabaseConnection->simpleSelect($from, array $where = [], array $columns = [], $order_by = null,! \\ \lstinline!   $group_by_having = null, $limit = null, $join = '', $force_statement = false)!, \\ \lstinline!DatabaseConnection->simpleUpdate($table, array $newValues, array $whereColumns)! and \\ \lstinline!DatabaseConnection->simpleDelete($from, array $whereColumns)! \\
            Those functions are identical to their ``non-simple'' versions with the only difference that they expect not a \mysql!WHERE! string but an associative array with conditions.
         \item \lstinline!DatabaseConnection->lastInsertId($table = '', $keyField = 'id')! \\
            Gets the last insert id. The arguments are only required when using \texttt{pgsql} driver.
      \end{itemize}
      \paragraph{Remarks considering Binary Large Objects (BLOBs)}
         In PHP, there is no difference between BLOB data and a string. However, FIM needs to know which data is of type BLOB as PDO uses a special binding type for those. The usage of this type might be favorable, as some database drivers (most notably MySQL) will refuse to perform queries (and might close the connection unexpectedly) if they are bigger than a server-defined constant. But don't expect PDO to handle data properly that is larger than allowed by server constraints. Even when using the correct data type, your connection might simply die. \\
         FIM provides the class \lstinline!Blob! that can be instantiated with the string that holds the blob data as its parameter. Objects of this type can be passed as \mysql!WHERE! condition or \lstinline!$bind! parameter array entry and will be recognized properly.
   \subsection{Executor}
      This file does not contain any class or function in public namespace. The internal class \lstinline!fim\Executor! is responsible for the whole process of deciding which data should be passed to the user and takes the appropriate measures. If it is ever necessary to access this class, refer to the doccomments and the source.
   \subsection{FileUtils}
      FIM provides several methods that help to overcome some of PHP's problems when dealing with files. \\
      Calculation of file sizes greater that exceed \lstinline!PHP_INT_MAX! will be very unreliable when using \lstinline!filesize!. For this purpose, the method \lstinline!fileUtils::size($fileName)! returns the exact size of a file in bytes, regardless whether PHP is running as 32~bit or 64~bit application and which operating system is used. The return value will be an integer or double representation of the file size (while double is potentially imprecise, differences of at least one byte will not occur until a file is at least 9~PB large---if this case ever occurs, you may change FIM's implementation to return a string instead of a number). \\
      PHP might also not recognize the existence or readability of large files; for this purpose, you can use \lstinline!fileUtils::isReadable($fileName)! or \lstinline!fileUtils::fileExists($fileName)!. \\
      A problem that only occurs when PHP is running on Windows is dealing with Unicode filenames. As PHP on Windows is not compiled as a Unicode-aware application, those files are inaccessible. However, Windows provides a technique that allows to extend the range of available characters a bit. By \emph{encoding} a filename in a proper codepage, \emph{some} filenames might become available. For this purpose, FIM provides the methods \lstinline!fileUtils::encodeFilename($utf8FileName, $mask = false)! (\lstinline!$mask! determines whether invalid characters will become question marks (\lstinline!true!) or raise an exception) and \\
      \lstinline!fileUtils::decodeFilename($codepageFileName)!. Let's take the filename \texttt{â¬uro.txt}. If you want to call e.g.\ \lstinline!filesize()! on this file, you will get an exception---the Euro symbol is character \lstinline!0x20AC! in the Unicode table and cannot be used in non-Unicode applications. However, assuming the current codepage is 1256 (which is common is western Europe), the character \lstinline!0x80! (which has no visual representation) will be treated as the Euro symbol. By encoding the Unicode filename, you will be able to get all the statistics of this file. Codepages are nice means to extend the character range, but they are very limited on the other hand. With the codepage 1256, you will---for example!---never be able to access a file that contains a \texttt{Ä}\footnote{You may have quickly tried what I just wrote and were successful with accessing the Euro-named file. If you however open your test script in a HEX editor, you will see that Euro symbol was saved as character \lstinline!0x80!---your source editor did the encoding for you. If the Unicode representation was used, you would have run into problems.}. \\
      Those functions are all intended for use with a single file or directory. If you wish to iterate through directories, you would normally make use of PHP's \lstinline!DirectoryIterator!. Use the class \lstinline!fimDirectoryIterator! instead which will do all the necessary conversions and assure that no exception occurs when a file with problematic characters in its name is reached.
      \paragraph{Implementation details}
         All the problems of PHP can't be solved without the help of extensions or external applications. The \lstinline!fileUtils::size! function will try to get the file size with cURL, native \lstinline!fopen! (up to 4~GB) or the execution of an external application. On *nix systems, a call of \texttt{stat} will do the job while on Windows, FIM delivers a special application that is invoked. FIM's directory iterator will call this application as well. For this purpose, either the module COM or the function \lstinline!exec! has to be available. \\
         In case of unexpected results you should have a look at the source. The different situations are well-commented. \\
         Credit for the implementation of code page encoding and decoding goes to Umberto Salsi (icosaedro.it).
   \subsection{FIM}
      This file provides the function \lstinline!fimInitialize(array $config = [])!, which has to be called by the controller. The parameter is an associative array that might contain any of the configuration entries as described above. \\
      If you need to executing some code whenever a resource is requested, you may provide the files \texttt{fim.startup.php} or \texttt{fim.shutdown.php} in ResourceDir which will be executed before and after the executor takes over. These files won't be called when the subdomain base error script is executed.
   \subsection{I18N}
      All internationalization capabilities of FIM are bundled in the class \lstinline!I18N!. FIM differs between two locales: The internal locale is the one used by FIM to display its own messages while the ``normal'' locale is the one used by your application. Those two locales are represented as instances of the \lstinline!I18N! class. You cannot create such an instance by yourself, but you have to make use of the static methods of the class:
      \begin{itemize}
         \item \lstinline!I18N::getSupportedLocales($checkFor = I18N::SUPPORTED_LOCALES)! \\
            This method returns an array that contains all available locales (or languages, regions or scripts, depending on the parameter) as strings. Those strings can then be used to call \lstinline!I18N::setLocale! or for different purposes. \\
            Note that in contrast to the ICU function \lstinline!ResourceBundle::getLocales!, this one does not require to create a list of available locales and store this list in a resource file but instead checks the \texttt{//locales} directory. However, function results will be cached similar to the other ICU routines until the server restarts, if possible.
         \item \lstinline!I18N::getLocale()! \\
            This function returns the \lstinline!I18N! object of your application's locale.
         \item \lstinline!I18N::getInternalLocale()! \\
            This function returns the \lstinline!I18N! object of FIM's internal locale. Generally, there should not be any need to call this function.
         \item \lstinline!I18N::setLocale(I18N|string $locale)! \\
            The application's locale is set to the object given as parameter. If the parameter is a string, a new \lstinline!I18N! object is created that represents the given locale. The return value will be the new locale object or \lstinline!false! if the process failed.
         \item \lstinline!I18N::detectBrowserLocale(array $acceptedLocales = null, $fallback = 'en')! \\
            By using the information available from the user's browser, this function tries to return a locale string that fits best. Valid locale strings have to be passed as first parameter; if the parameter is omitted, all supported locales are taken into account. If no locale whatsoever fits, the fallback will be returned.
      \end{itemize}
      The methods of a \lstinline!I18N! instance finally provide the abilities to localize:
      \begin{itemize}
         \item \lstinline!I18N->get($key, array $args = [])! \\
            The entry \lstinline!$key! is looked up in the current ResourceBundle. If \lstinline!$key! is an array, FIM will handle the individual entries as keys of a table structure. \\
            If the key does not exist, FIM will report an error and return the string representation of the key instead. By setting the configuration entry \lstinline!'localeRawFallback'! to \lstinline!true!, FIM will instead treat the key name as if it were the result of the lookup. \\
            If the result is a string and \lstinline!$args! is not empty, FIM will apply message formatting and return the formatted value. ICU's support for message placeholders is quite extensive. However, I have not found a complete documentation yet. \url{http://userguide.icu-project.org/formatparse/messages} might be a good place to start, as well as \url{http://icu-project.org/apiref/icu4c/classMessageFormat.html#details}.
         \item \lstinline!I18N->getLocaleId()!, \lstinline!I18N->getLanguageId()!, \lstinline!I18N->getRegionId()!, \lstinline!I18N->getScriptId()! \\
            Returns the respective identifiers of the current object.
         \item \lstinline!I18N->getLocaleName()!, \lstinline!I18N->getLanguageName()!, \lstinline!I18N->getRegionName()!, \lstinline!I18N->getScriptName()!, \lstinline!I18N->getVariantName()! \\
            Returns the respective identifiers of the current object in a human-readable format.
         \item \lstinline!I18N->formatSize($size, $digits = 0, $binary = true, $thinsp = false)! \\
            Returns a string that is composed by the \lstinline!$size! parameter, but with appended SI suffixes. If \lstinline!$size! is a double value, \lstinline!$digits! defines the number of digits after the decimal dot. If \lstinline!$binary! is true, the binary suffixes \texttt{kiB}, \texttt{MiB}, ... are used with $1024$ as divider instead of $1000$. If you want the number and its suffix separated by a thin space (Unicode \lstinline!0x2009!) instead of a normal space, set the forth parameter to \lstinline!true!.
         \item \lstinline!I18N->formatNumber($number, $format = NumberFormatter::DECIMAL, $type = NumberFormatter::TYPE_DEFAULT)! \\
            Formats a number with the given settings. This function acts as a more comfortable wrapper around \lstinline!NumberFormatter->formatNumber()!. The most interesting values for the second parameters should comprise \lstinline!NumberFormatter::DECIMAL!, \lstinline!NumberFormatter::PERCENT! and \lstinline!NumberFormatter::CURRENCY!. Do not use \lstinline!NumberFormatter::CURRENCY!; use the \lstinline!I18N->formatCurrency! method instead.
         \item \lstinline!I18N->formatCurrency($currency, $type = 'USD')! \\
            Formats a number in currency format using the given type as currency symbol. The type has to be in three-letter ISO 4217 currency code format.
         \item \lstinline!I18N->formatDate($timestamp, $format = IntlDateFormatter::MEDIUM)!, \\\lstinline!I18N->formatTime($timestamp, $format = IntlDateFormatter::MEDIUM)! and \\\lstinline!I18N->formatDateTime($timestamp, $dateFormat = IntlDateFormatter::SHORT, $timeFormat = IntlDateFormatter::MEDIUM)! \\
            Those functions are responsible for formatting UNIX timestamps to human-readable form. Examples for all possible parameter values are given in the doccomments.
         \item \lstinline!I18N->translatePath($path)! \\
            Sometimes, raw data needs to be localized. The ResourceBundle format allows to include this data in its files, but it is also possible to create a directory/file structure that is localizable. If your localized images are located in \texttt{/img/<locale identifier>/...}, simply pass the name of a file to this function using the short placeholder \texttt{<L>}: \\
            \lstinline!$i18n->translatePath('/img/<L>/logo.png')! will search for the file \texttt{logo.png} in a subdirectory of \texttt{/img} that matches the current locale as good as possible. \lstinline!false! is returned if the file cannot be found using fallback mechanisms as ICU does (so fallback to the system's locale and then to \texttt{root}).
         \item \lstinline!I18N->parse...! \\
            Those functions are the counterparts of the \lstinline!format...! functions. They will do the reverse job and convert human-readable data to machine-readable.
         \item \lstinline!I18N->getTimezone()!, \lstinline!I18N->setTimezone(IntlTimeZone $timeZone)! \\
            These functions get or change the current time zone. Time zones will affect the output of formatting and parsing timestamp functions. Note that at least PHP~5.5 is required for a support of those functions as the \lstinline!IntlTimeZone! class is not available before.
         \item \lstinline!I18N->getCalendar()!, \lstinline!I18N->setCalendar(IntlCalendar $calendar)! \\
            As before, these functions get or change the current calendar which also affects the output of formatting and parsing timestamp functions. Once again, PHP~5.5 is required.
      \end{itemize}
   \subsection{Log}
      The log class allows access to FIM's three log files. The only function that should be called in your application is \lstinline!Log::reportCustomError($message, $noMail = false)!. It writes the first parameter to the custom log and sends a mail notification to the address specified in the configuration, if the second parameter is not set to \lstinline!true!. \\
      The other functions are not intended to be used by your application. The reporting functions will all do the same, just writing to different logs. The handler functions are only public as PHP requires this and are called manually not even by FIM.
   \subsection{Memcached}
      FIM provides several ways to emulate the extension \texttt{Memcached}. The wrapper around the old extension \texttt{Memcache} will provide an interface to you that is designed exactly as the one of the newer extension. If neither one of those is installed, FIM will provide a standalone client that directly communicates with Memcached by using socket functions and once again has the same behavior as the one of the new \texttt{Memcached} extension. \\
      Note that those replacements are only intended for development use. You should not make use of them in a production system. Some features are only pretended: Connections to multiple servers won't work. While both replacements won't throw an error, they will simply connect to the weightiest server (if the wrapper is used and a ``new'' version of the old extension is installed, multiple servers work). SASL authentication will always throw an exception. Most parts of the configuration simply don't change the behavior. So these replacements are powerful in lots of ways, but not that sophisticated. Note that the standalone client requires newer versions of Memcached that support the binary protocol.
   \subsection{Module}
      This is the base class for all modules. Most of its methods are only available to the module object itself. Assigning a variable to the module object will make this variable available in Smarty templates.
      \begin{itemize}
         \item \lstinline!public function execute(...)! \\
            This function has to be implemented in modules if they are executable. It will be called with autoboxing.
         \item \lstinline!public function handleError($errno)! \\
            This function can be implemented in modules that perform error handling.
         \item \lstinline!public function handleError...()! \\
            These functions can be implemented in modules that perform error handling of the error number \lstinline!...!.
         \item \lstinline!Module->getModulePath()! \\
            This function returns a FIM normalized path of the folder the module file is stored in.
         \item \lstinline!$this->fetchTemplate($templateFile)! \\
            This function returns the output of the template that is stored in \lstinline!$templateFile!.
         \item \lstinline!$this->displayTemplate($templateFile)! \\
            The output of the template \lstinline!$templateFile! is sent to the output buffer.
         \item \lstinline!$this->setContentType($newMIMEType, $newCharset = null)! \\
            This is a shortcut that allows to set the content type easier than using \lstinline!Response::set!. The first parameter can either be a string or an array. If it is an array, content negotiation will be applied to it (see the section in the reference of the \lstinline!Response! class). If it is a string, a valid MIME type or a file name with extension is expected. \\
            If no charset is given, the default value from the configuration is taken or the previous charset if one was already passed as a content type header.
         \item \lstinline!$this->displayFile($fileName, $checkAccess = 0, $requireSubdirectory = null)! \\
            The file that is referred to in the FIM path \lstinline!$fileName! is outputted as if it was requested by the user. \\
            It is possible to check the rules before performing the task. For this purpose, the second parameter may be a bitmask composed of \lstinline!Rules::CHECK_EXISTENCE! and \lstinline!Rules::CHECK_READING!. If rules denied access, an error is raised. \\
            If the third parameter is set, a 404 error will also be triggered when the file is not located within the directory that is given there.
         \item \lstinline!$this->error($errno)! \\
            Triggers an error that can be handled by error handling routines of modules. Execution is aborted after this function.
         \item \lstinline!$this->getErrorDetails()! \\
            Returns information about where the last error that was triggered \emph{manually} occurred (see the doccomment for information about the return type). If no error occurred or the last error was caused by FIM (rules etc.), the return value will be \lstinline!null!.
         \item \lstinline!$this->forward($to, array $parameters = null, $keepTemplateVars = true, $checkRules = true)! \\
            This function expects a valid FIM path as first parameter. The requested resource will be executed as if is was the URL (but note the difference: Do not pass a URL as first parameter but a FIM path!). If the resource is a directory containing a module, you can change the current parameters with the second argument if you wish to. \\
            By default, all variables that were assigned to the current module will be kept in the new one, but you may erase them with the third parameter. \\
            The last parameter finally determines whether FIM should check the access rights (existence/reading/listing, whatever is necessary). \\
            Execution will stop after this function was called.
         \item \lstinline!$this->redirect($to, array $parameters = [])! \\
            This function will perform an \emph{external} redirect (so it's the user's browser that does it) to another resource which has to be given as valid FIM path as first parameter. GET parameters can be passed as second argument. \\
            Execution will stop after this function was called. \\
            If the FIM path could not be converted to a URL, an exception is raised.
      \end{itemize}
   \subsection{PrimaryTable}
      This file provides the base class \lstinline!PrimaryTable! as well as data helper utilities. The class \lstinline!PrimaryTable! should be used as a superclass for every table that contains at least one primary key. \\
      The extending class is required to define the protected static property \lstinline!$columns!, which has to be initialized as an associative array. The keys correspond to the column names, the values indicate the data type. Valid types are \lstinline!'string'!, \lstinline!'int'!, \lstinline!'double'!, \lstinline!'bool'!, \lstinline!'blob'! (which will be represented as a string, but has different internal handling) or a class name. This class has to implement either the \lstinline!DataHelper! or the \lstinline!fimSerializable! interface. Any of these types have to be prepended either with \texttt{+} if they are auto-increment, \texttt{*} if they are primary keys or \texttt{0} if \lstinline!null! is allowed (not for data helpers). \\
      Data helpers are classes that implement the \lstinline!DataHelper! interface or extend the base class \lstinline!DataHelperPrimitive!. The column will be represented as an object of this class, although it is stored in a different format in the database (thus e.g.\ allowing an easier way to handle bitmasks or similar data). The data helper will be ``bound'' to a certain object with the function \lstinline!DataHelper->bind(PrimaryTable $row, $fieldName, $value, callable $change)!. It must report any change to its value by invoking the callable \lstinline!$change! (which does not expect any parameter). The connection between data helper and table entry has to be released when \lstinline!DataHelper->unbind()! is called. Finally, the function \lstinline!DataHelper->getStorageValue()! has to return the database representation of the current value. \\
      The base class \lstinline!DataHelperPrimitive! implements all those methods. It thus simplifies the process of creating a data helper. When extending this class, you don't need to deal with the communication aspects except from calling the protected function \lstinline!$this->setValue($value)! whenever the (already provided) property \lstinline!$this->value! changes. \\
      A primary table itself provides lots of methods (but note that a \lstinline!PrimaryTable extends Table!, so also see the reference of \lstinline!Table!):
      \begin{itemize}
         \item
            The necessary methods for being FIM-serialized and unboxed are supplied. Unboxing requires the existence of one auto-increment or only one primary key which is used as identifier. The \lstinline!PrimaryTable::unbox($key)! method can however be overwritten, if more specific features are required.
         \item \lstinline!$this->makeDBRepresentation()! \\
            Table entries can be marked as ``virtual'', i.e.\ they do not exist in the database but only in the application. This function will add the current, virtual table entry to the database and change its state accordingly.
         \item \lstinline!$this->delete()! \\
            Removes the current object from the database and unbinds all existing data helpers.
         \item \lstinline!self::createNew(...$columns)! \\
            This function has to be called from a subclass. It expects the values for all columns in the order as given in the \lstinline!self::$columns! property, excluding a possible auto-increment value. \\
            As last argument, \lstinline!true! might be given. This will make the entry ``virtual'', so that it is not added to the database.
         \item \lstinline!self::translateStatement(PDOStatement $result)! \\
            This function converts the results from a database statement into objects of the current class.
         \item \lstinline!self::findBy(array $where = [], $orderBy = null)! \\
            Returns an array of objects of this class that fulfill given conditions. The first parameter expects an associative array that assigns an exact value to a column. The second parameter can be any valid SQL string that shall follow the \mysql!ORDER BY! keyword.
         \item \lstinline!self::getBy($where = null, array $bind = null, $order_by = null, $group_by_having = null,! \\ \lstinline!   $limit = null, $join = '')! \\
            For more complex queries, use this function. Here you can specify the \mysql!WHERE! condition as a string. You may make use of placeholders which can then be bound by using the second argument. The remaining parameters are string as well that will be inserted directly into the SQL string.
         \item \lstinline!self::findOneBy(array $where, $orderBy = null)! and \\
            \lstinline!self::getOneBy($where = null, array $bind = null, $order_by = null, $group_by_having = null,! \\ \lstinline!   $limit = null, $join = '')! \\
            These functions behave like their more general counterparts, but return only the first object or \lstinline!null! if there were no results.
      \end{itemize}
   \subsection{ReflectionFile}
      The class \lstinline!ReflectionFile! is required by FIM to analyze your application's code and generate appropriate autoboxing cache files. But as the functionality of this might be of some use for you, you may use the class \lstinline!ReflectionFile! to apply PHP's reflection to a whole file. \\
      Credit for the implementation goes to Zend Framework.
   \subsection{Request}
      This class provides several methods that unify the access of request data.
      \begin{itemize}
         \item \lstinline!Request::get($param, $default = null)! \\
            Returns the entry \lstinline!$param! from the GET parameters.
         \item \lstinline!Request::post($param, $default = null)! \\
            Returns the entry \lstinline!$param! from the POST parameters.
         \item \lstinline!Request::boolGet($param, $default = false)! \\
            Returns the entry \lstinline!$param! from the GET parameters as a boolean; lots of different ways of submitting a boolean value are recognized.
         \item \lstinline!Request::boolPost($param, $default = false)! \\
            Returns the entry \lstinline!$param! from the POST parameters as a boolean; lots of different ways of submitting a boolean value are recognized.
         \item \lstinline!Request::hasGet($param)! \\
            Returns whether a certain GET parameter exists.
         \item \lstinline!Request::hasPost($param)! \\
            Returns whether a certain POST parameter exists.
         \item \lstinline!Request::hasFile($param, $checkSuccess = false)! \\
            Returns whether a certain file was present; if the second parameter is true, FIM additionally checks whether the upload was successful.
         \item \lstinline!Request::itemize($filter = null, $post = true, $iterator = false, $matchFlag = RegexIterator::MATCH)! \\
            Returns an array or iterator (set the third parameter appropriately) of all the data that was submitted via POST or GET (depending on the second parameter). Additionally, a regular expression can be applied to the data, so that only certain keys are returned by using the first parameter.
         \item \lstinline!Request::getFileError($param)! \\
            Returns the error that occurred when the file identified by \lstinline!$param! was tried to be uploaded. The return value will be one of PHP's \lstinline!UPLOAD_ERR_*! constants.
         \item \lstinline!Request::saveFileUpload($param, $to)! \\
            Stores a file upload to a given location, \lstinline!$to! being a valid FIM filepath.
         \item \lstinline!Request::getFileContent($param)! \\
            Retrieves the content of a file as a string value.
         \item \lstinline!Request::getFileResource($param)! \\
            Retrieves a valid \lstinline!fopen! handle to a given file. As this is a temporary file it will be opened with \lstinline!'rb'! privileges.
         \item \lstinline!Request::getFileName($param, $default = null, $encodeName = true)! \\
            Retrieves the user-defined name of a file upload; with the third parameter, it is possible to automatically encode the file name into a proper code page name.
         \item \lstinline!Request::getFileSize($param, $default = null)! \\
            Retrieves the file size of a file upload in bytes
         \item \lstinline!Request::getFileType($param, $default = null)! \\
            Retrieves the MIME type of a file upload. Warning: This value is not reliable as it is set by the client and not validated internally!
         \item \lstinline!Request::getFileTemporaryName($param, $default = null)! \\
            Retrieves the temporary name of a file upload.
         \item \lstinline!Request::getFileDetails($param, $encodeName = true)! \\
            Retrieves an associative array holding all details regarding a specific file upload. Use this function instead of calling \lstinline!getFileError!, \lstinline!getFileName!, \lstinline!getFileSize! or \lstinline!getFileTypes! one after the other.
         \item \lstinline!Request::getURL($parameters = false)! \\
            Gets the current URL that was requested. This does not include subdomains or the server name and no parameters as well. BaseDir will be truncated if necessary. The URL will start with a slash. \\
            If the first parameter is set to \lstinline!true!, GET parameters will be included as well.
         \item \lstinline!Request::getParameterString()! \\
            Gets the current parameter string that is appended to the URL, starting with the delimiter character. An empty string if there were no parameters.
         \item \lstinline!Request::isHTTPS()! \\
            Determines whether the request was sent via HTTPS.
         \item \lstinline!Request::isPost()! \\
            Determines whether the request method was POST.
         \item \lstinline!Request::isGet()! \\
            Determines whether the request method was GET.
         \item \lstinline!Request::postSizeExceeded()! \\
            Determines whether a POST request was started but the maximum POST size was exceeded. This can happen when there were too large file uploads and it means that no POST variable is available.
         \item \lstinline!Request::saveURL()! \\
            Saves the current url so that it can be restored in further processing. As this will be saved for new requests until it is restored, this function can e.g.\ be used to redirect to an inaccessible page after login.
         \item \lstinline!Request::restoreURL()! \\
            Performs a redirect to the url that was saved with ::saveURL(). Execution will not be halted (unlike module forward or redirect functions)!
         \item \lstinline!Request::getBrowser()! \\
            Determines the browser the user used according to the user agent. For details see the doccomment.
         \item \lstinline!Request::getPort($insertable = false)! \\
            Returns the port that is used for the current request. The parameter specifies whether a string, starting with a colon (or an empty string, if the default port is used), or an integer shall be returned.
         \item \lstinline!Request::getFullURL($includePath = true)! \\
            Returns the full URL with which the request was started, including protocol, host and path. \\
            Set the first parameter to false in order only to get the host. The URL will not contain a trailing slash.
         \item \lstinline!Request::getMaxUploadSize()! \\
            Gets the maximum number of bytes that can be uploaded. This is the minimum value of \texttt{php.ini}'s \texttt{upload\_max\_filesize}, \texttt{post\_max\_size} and \texttt{memory\_limit}.
      \end{itemize}
   \subsection{Response}
      The \lstinline!Response! class provides several means to control the output to the user.
      \begin{itemize}
         \item \lstinline!Response::$responseText! \\
            This variable contains the whole output. FIM activates output buffering; after your application finished, anything that was \lstinline!echo!ed before will be appended to this variable. It is therefore possible to \emph{pre}pend something to the output at any stage of code execution by setting this variable directly instead of using \lstinline!echo! or \lstinline!print!.
         \item \lstinline!Response::$responseCode = 200! \\
            Set this to change the http response code header. Default is $200$ (OK).
         \item \lstinline!Response::getMIMEType($filename)! \\
            Determines the MIME type based on the filename's extension. FIM has built-in support for about one thousand extensions. If you notice any problems with this function, please contribute your MIME type!
         \item \lstinline!Response::translateHTTPCode($code)! \\
            Transforms the given HTTP status code to its textual meaning. Hint: This function is not localized and will return the official string representations of the codes!
         \item \lstinline!Response::headers(array $new = null)! \\
            Lists all headers that will be sent or replaces them altogether. By specifying an associative array as parameter, \emph{all} the current headers will be removed and replaced by the new ones!
         \item \lstinline!Response::get($name, $default = null)! \\
            Gets a specific header
         \item \lstinline!Response::has($name)! \\
            Checks whether a specific header exists
         \item \lstinline!Response::set($name, $value, $overwrite = true)! \\
            Sets a header field. \lstinline!$name! and \lstinline!$value! will be normalized. \\
            In order to set a \texttt{Content-Disposition} file name, set the content disposition field and do not use any quotes or escaping for the filename. FIM will escape it properly for any browser that is used.
         \item \lstinline!Response::delete($name)! \\
            Deletes a specific header field.
         \item \lstinline!Response::expire($time)! \\
            Sets an \texttt{Expires} header in the request. If this function is not called, the default expiring time will be one month. \\
            Module pages and parsed files will expire at once by default. Response codes that differ from $200$ (OK) will expire also at once.
         \item \lstinline!Response::cache($expires, $mustRevalidate)! \\
            Deals with the caching mechanism. Sends an \texttt{Expires} header and \texttt{must-revalidate} and its HTTP/1.0 equivalents.
         \item \lstinline!Response::contentNegotiation(array $contentTypes, $charset = null)! \\
            Sets a content type based on the \texttt{Accept} header of the client. \\
            The first parameter has to contain acceptable content types. Preferred  ones come first. You \emph{have to} give one value that has the key \lstinline!'*'!; this content type will be set if no other type matches the \texttt{Accept} header. If you forget to do so, an exception will be thrown.
         \item \lstinline!Response::doSend()! \\
            This function sends all headers that were specified before and then outputs the response text. \\
            Do not call this function manually unless you use this class in the subdomain base error script.
         \item \lstinline!Response::mail($to, $subject, $message, $from = null, $html = false, array $attachments = [])! \\
            This functions sends an e-mail. It uses the PHPMailer script that is delivered with FIM for this purpose. It is possible to use PHPMailer on your own if you need to make use of its more advanced capabilities than the ones offered in this function. \\
            See the documentation of \href{https://github.com/PHPMailer/PHPMailer}{\color{blue}PHPMailer} for an insight in its structure. FIM will automatically make the class \lstinline!PHPMailer! available; the default \texttt{From} header will be set to the configuration setting \lstinline!'mailFrom'!
      \end{itemize}
   \subsection{Router}
      The \lstinline!Router! class contains lots of static methods that are necessary to deal with path mappings (URL $\leftrightarrow$ FIM path $\leftrightarrow$ file system path). It can however be extended and subclasses will be instantiated in order to perform routings, as they are explained in \autoref{routing}.
      \begin{itemize}
         \item \lstinline!Router::normalizeFIM($path, $returnArray = false)! \\
             Normalizes a path in FIM style. The returned path will start with two slashes and will not end with a slash (if it is a string, as can be controlled with the second parameter). Note that the result of this function might depend on the current working directory.
          \item \lstinline!Router::normalizeFilesystem($path, $returnArray = false)! \\
             Normalizes a path in filesystem style. The returned path will start with a slash or drive letter and will not end with a slash. This function understands the two protocols \texttt{fim://} and \texttt{file://}, if given.
          \item \lstinline!Router::convertFIMToFilesystem($fimPath, $normalize = true)! \\
             Converts a FIM path to an absolute path.
          \item \lstinline!Router::convertFilesystemToFIM($filesystemPath, $normalize = true)! \\
             Converts a filesystem path to a FIM path, if possible (else \lstinline!false! is returned).
          \item \lstinline!Router::mapURLToPath($url, &$parameters, &$noRouting = null, &$failureAt = null)! \\
             Converts a given URL to a normalized path respecting given routings. The third parameter will be set to \lstinline!true! if no routing will ever occur to the given URL, regardless of its parameters. The forth parameter will be set to the last directory that could be mapped successfully and thus allows to see at which level the routing process failed.
          \item \lstinline!Router::mapPathToURL($path, array $parameters = [], &$noRouting = null, $allServers = false)! \\
             Converts a given path with parameters to a URL. The last parameter controls whether an array is returned with the first entry being the part before the server string, the second one the part after the server part. A string is returned when the last parameter is \lstinline!false! or if the URL would be the same, regardless of server settings. This is only important if you allowed multiple entries in the \lstinline!'subdomainBase'! settings.
          \item \lstinline!protected abstract rewriteURL(array $url, array &$parameters, &$stopRewriting)! and \\ \lstinline!protected abstract rewritePath(array $path, array &$parameters, &$stopRewriting)! \\
             These functions have to be implemented by subclasses. They are explained in \autoref{routing} and in the doccomments.
      \end{itemize}
   \subsection{Rules}
      The \lstinline!Rules! class is base class for all rules that control resource access. Setting any property to the rules object will assign it to Smarty templates. The class contains static methods that apply the rules:
      \begin{itemize}
         \item \lstinline!Rules::check($fileName, $checkFor)! \\
            Checks whether a bitmask of rights can be applied to a certain file or folder. The result will be cached. The second parameter is composed of the class constants \lstinline!Rules::CHECK_EXISTENCE!, \lstinline!Rules::CHECK_READING! and \lstinline!Rules::CHECK_LISTING!. The shortcut value \lstinline!Rules::CHECK_ACCESS! is a composition of all those three.
         \item \lstinline!Rules::checkFilterExistence($fileName)! \\
            Checks whether for a specific location a rule exists. \\
            This function only checks for the existence of \texttt{fim.rules} files, not what these files will do.
         \item \lstinline!Rules::clearCache($checkCache = Rules::CHECK_ACCESS)! \\
            Clears the cache for checked rules. Calling this might be necessary after an update of login credentials or similar operators.
         \item \lstinline!$this->checkSimpleAccess($fileName, $checkFor)! \\
            Checks the recommendation that the simple rules file in the same folder as the rules script gives for a certain file name.
         \item \lstinline!public function checkExistence($fileName, $fullName)!, \\ \lstinline!public function checkReading($fileName, $fullName)! and \\ \lstinline!public function checkListing($fileName, $fullName)! \\
            Those functions can be overwritten in subclasses and shall return values as described in \autoref{rules}. The default implementation will do nothing and return \lstinline!null!.
      \end{itemize}
   \subsection{Semaphore}
      FIM provides a class that allows synchronization. This class can be used in two modes: The first one will act as a process-only semaphore, locks will only apply to the current process. The second one can span multiple servers on multiple computers and is thus able to synchronize a whole data center. While the first option will work best with one of the extensions \texttt{Semaphore}, \texttt{Wincache}, \texttt{APC}, \texttt{XCache}, \texttt{Redis} or \texttt{Memcached}, the unavailability of all these will not break its functionality. The second option however requires Redis or Memcached to be set up properly.
      \begin{itemize}
         \item \lstinline!Semaphore::__construct($name, $multiServer = false)! \\
            Creates a new object. Semaphores are identified by their name.
         \item \lstinline!Semaphore->__destruct()! \\
            A semaphore is unlocked automatically when its object goes out of scope.
         \item \lstinline!Semaphore->lock()! \\
            Acquires an exclusive lock. This function will return \lstinline!true! if the lock was successfully. Calling this function will make any other Semaphore object of this name that tries to acquire the lock wait until it is released.
         \item \lstinline!Semaphore->unlock()! \\
            Releases the lock. If the result is \lstinline!false!, a problem occurred.
      \end{itemize}
   \subsection{Serialization}
      PHP's method \lstinline!unserialize! has a serious drawback: it automatically creates the object that shall be unserialized. This instance will then be refilled with the data. FIM needs the capability to unserialize singletons, so the functions in this file work as a replacement for PHP's serialization methods. \\
      The interface \lstinline!fimSerializable! has to be implemented by every class that can be serialized. Its \lstinline!fimSerialize()! method has to return a string that contains the serialized content of the object; the \emph{static} method \lstinline!fimUnserialize($serialized)! returns the unserialized object and is responsible for its creation as well. \\
      The global methods \lstinline!fimSerialize($arg)! and \lstinline!fimUnserialize($serialized)! then work exactly as their PHP counterparts.
   \subsection{Session}
      The \lstinline!Session! class provides several static methods that allow to preserve data between different requests. Note that in command line mode, none of these methods will work.
      \begin{itemize}
         \item \lstinline!Session::$memcached! and \lstinline!Session::$redis! \\
            Holds instances of \lstinline!Memcached! and \lstinline!Redis! or \lstinline!Predis!, if you made the appropriate settings.
         \item \lstinline!Session::get($name, $default = null)! \\
            Gets a session variable
         \item \lstinline!Session::has($name)! \\
            Checks whether a specific value is stored within a session.
         \item \lstinline!Session::set($name, $value, $overwrite = true)! \\
            Sets a session variable.
         \item \lstinline!Session::delete($name)! \\
            Removes a session variable.
         \item \lstinline!Session::clear($onlyStatic = true)! \\
            Removes all the session variables. The parameter indicates whether flash variables shall also be removed.
         \item \lstinline!Session::getFlash($name, $default = null, $extend = false)! \\
            Gets a temporary session variable. Those are only available for the very next module invocation (excluding internal forwards) and deleted afterwards.
         \item \lstinline!Session::hasFlash($name)! \\
            Checks whether a specific temporary value is stored within a session.
         \item \lstinline!Session::setFlash($name, $value, $overwrite = true)! \\
            Sets a temporary session variable that will only be accessible within the very next request.
         \item \lstinline!Session::deleteFlash($name)! \\
            Removes a temporary session variable.
         \item \lstinline!Session::extendFlash($name)! \\
            Extends the lifetime of a temporary session variable so it will stay one more request alive.
         \item \lstinline!Session::extendFlashs()! \\
            Extends the lifetime of all temporary session variables.
         \item \lstinline!Session::getConst($name, $default = null)! \\
            Gets a FIM constant. Those are values that won't be stored for the next request, but they are stored for the current execution and can be thought of an alternative to PHP's constants. The advantage of FIM's ``constants'' is that they are variable.
         \item \lstinline!Session::hasConst($name)! \\
            Checks whether a specific constant is known to FIM.
         \item \lstinline!Session::setConst($name, $value, $overwrite = true)! \\
            Sets a FIM constant.
         \item \lstinline!Session::deleteConst($name)! \\
            Removes a FIM constant.
         \item \lstinline!Session::getId()! \\
            Returns the current session id.
         \item \lstinline!Session::renewId()! \\
            Renews the session id with respect to the session transition. Renewal is not possible when the current session is a transition session which was already replaced by another one (see configuration reference).
         \item \lstinline!Session::replaceId($newId)! \\
            Replaces the current session id with a new one. The session's lifetime will be set appropriately. It will not be possible to access the session under its old id.
         \item \lstinline!Session::setLifetime($lifetime = 0)! \\
            Sets the lifetime of the session cookie used by the framework. A lifetime of zero means that the cookie expires when the browser window closes (default). All other values are in seconds, calculated from now. This does not have anything to do with the session configuration.
      \end{itemize}
   \subsection{Smarty}
      This file provides the template functions \smarty!{url}!, \smarty!{lurl}! and \smarty!{L}! which are described in detail in the explanations of \autoref{tf1} and \autoref{tf2}.
   \subsection{Table}
      The base class for all table-like structures that do not necessarily contain primary keys is \lstinline!Table!. By extending this class, subclasses will have a protected variable \lstinline!$fields! available that contains the data of the table entry. By setting or getting properties of the object, the contents of this variable are changed. \\
      A setter for the individual fields may be defined by creating a method names \lstinline!protected function set...($value)! where \lstinline!...! is the fields name. The setter has to return \lstinline!false! if FIM shall not set the field automatically to the new value. \\
      The protected function \lstinline!singleton($key, $action = 0)! can be used to manage singletons: Tables shall generally only be allowed to have one instance per row in a table; otherwise, data gets inconsistent. Therefore, this function can be called with the first parameter as a unique identifier of the current row. The second parameter may be \lstinline!0! (return the instance connected to this key), \lstinline!null! (remove this key's instance) or an object to store the instance. \\
      The function \lstinline!count()! will return the number of rows of the current table. \\
      Any table class needs quick access to its details which are the same for each object of a particular table class. For this purpose, a static storage is created. This storage is only filled once with all the necessary data (the \lstinline!Table! superclass will automatically determine the table name by using the class name) and can then be retrieved by calling \lstinline!$this->getStaticStorage($singleValue = null)!. The function will return the whole static storage array if \lstinline!$singleValue! is \lstinline!null! or the concrete entry with the key given as first parameter.
   \section{Final remarks}
   \subsection{Requirements}
      FIM requires at least PHP~5.4, 5.5 is recommended for full functionality. As PHP~5.6 has just left development state, FIM does not make use of its new features yet, although this is planned to be integrated. \\
      The server software has to support URL rewriting so that any request is forwarded to the front controller. Configuration examples for Apache~HTTPD or nginx can be found on \autopageref{htaccess} or \autopageref{nginx}. \\
      PHP has to provide the modules PDO (for database access, not needed if not desired), Intl (for internationalization, required). On Windows, either cURL, COM or \lstinline!exec! have to be available in order to use \lstinline!fileUtils!. \\
      In development, usage of XDebug is recommend while one of the PHP caches APC, XCache, Wincache, Zend cache, Opcache or similar engines should be used in production systems. Those caches must be required not to remove PHPDoc from the source! \\
      When Memcached shall be used, the extension Memcached is highly recommended (though FIM will also work with Memcache and without any of these two).
   \subsection{Acknowledgments}
      FIM makes use of several third-party libraries or parts of them. Alphabetically ordered:
      \begin{itemize}
         \item \href{https://github.com/ramsey/array_column}{\color{blue}array\_column} \\
         FIM will automatically make \lstinline!array_column! available for PHP~5.4 by using this library.
         \item \href{https://github.com/jkuchar/BigFileTools/blob/master/class/BigFileTools.php}{\color{blue}BigFileTools} \\
            The idea of \lstinline!fileUtils::size($fileName)! comes from BigFileTools, though the implementation differes a bit.
         \item \href{http://www.icosaedro.it/phplint/phplint2/libraries.htm}{\color{blue}PHPLint IO Library} \\
            Important parts of the encoding functions in \lstinline!fileUtils! come from Umberto Salsi, icosaedro.it
         \item \href{https://github.com/PHPMailer/PHPMailer/}{\color{blue}PHP Mailer} \\
         FIM uses PHPMailer as internal mail delivery system. PHPMailer is bundled with FIM and can be accessed directly.
         \item \href{http://www.smarty.net/}{\color{blue}Smarty} \\
            FIM uses Smarty~3 as template engine.
         \item \href{http://framework.zend.com/}{\color{blue}Zend Framework 2} \\
            The class \lstinline!ReflectionFile! comes from ZF~2 with only subtle changes.
         \item Other smaller snippets are marked directly in the source.
      \end{itemize}
   \subsection{Contribute}
      You may contribute to \fim{} on GitHub by reporting---or fixing---bug or localizing FIM in other languages. And you can of course \href{https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=J8369698KPE2W}{\color{blue}donate}.
\end{document}